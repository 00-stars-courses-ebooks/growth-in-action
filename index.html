<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Growth 实战篇 Django版 - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta name="viewport" content="width=device-width">
</head>
<body>
<h1>全栈增长工程师实战</h1>
<p>By <a href="https://www.phodal.com/">Phodal</a>(Follow me: <a href="http://weibo.com/phodal">微博</a>、<a href="https://www.zhihu.com/people/phodal">知乎</a>、<a href="https://segmentfault.com/u/phodal">SegmentFault</a>)
</p>

<p>GitHub: <a href="https://github.com/phodal/growth-in-action-django">全栈增长工程师实战</a></p>

<p>微信公众号</p>
<p><img src="https://raw.githubusercontent.com/phodal/growth/master/www/img/wechat.jpg" alt=""/></p>

<p>我的其他电子书：</p>
<ul>
<li>《<a href="https://github.com/phodal/growth-ebook">全栈增长工程师指南</a>》</li>
<li>《<a href="https://github.com/phodal/designiot">一步步搭建物联网系统</a>》</li>
<li>《<a href="https://github.com/phodal/github-roam">GitHub 漫游指南</a>》</li>
<li>《<a href="https://github.com/phodal/repractise">RePractise</a>》</li>
</ul>
<div style="width:800px">

<iframe src="http://ghbtns.com/github-btn.html?user=phodal&repo=growth-in-action-django&type=watch&count=true"
        allowtransparency="true" frameborder="0" scrolling="0" width="110px" height="20px"></iframe>
</div>

<h2>全栈增长工程师实战目录</h2>
<nav id="TOC">
<ul>
<li><a href="#growth-in-action-django">Growth In Action Django</a><ul>
<li><a href="#准备工作和工具">准备工作和工具</a></li>
</ul></li>
<li><a href="#深入浅出django">深入浅出Django</a><ul>
<li><a href="#django简介">Django简介</a><ul>
<li><a href="#django应用架构">Django应用架构</a></li>
</ul></li>
<li><a href="#django-helloworld">Django hello,world</a><ul>
<li><a href="#安装django">安装Django</a></li>
<li><a href="#创建项目">创建项目</a></li>
<li><a href="#django后台">Django后台</a></li>
<li><a href="#第一次提交">第一次提交</a></li>
</ul></li>
</ul></li>
<li><a href="#django创建博客应用">Django创建博客应用</a><ul>
<li><a href="#tasking">Tasking</a></li>
<li><a href="#创建blogpostapp">创建BlogpostAPP</a><ul>
<li><a href="#生成app">生成APP</a></li>
<li><a href="#创建model">创建Model</a></li>
<li><a href="#配置url">配置URL</a></li>
</ul></li>
<li><a href="#创建view">创建View</a><ul>
<li><a href="#创建博客列表页">创建博客列表页</a></li>
<li><a href="#创建博客详情页">创建博客详情页</a></li>
</ul></li>
<li><a href="#测试">测试</a><ul>
<li><a href="#测试首页">测试首页</a></li>
<li><a href="#测试详情页">测试详情页</a></li>
</ul></li>
</ul></li>
<li><a href="#功能测试与持续集成">功能测试与持续集成</a><ul>
<li><a href="#编写自动化测试">编写自动化测试</a><ul>
<li><a href="#selenium与第一个ui测试">Selenium与第一个UI测试</a></li>
</ul></li>
<li><a href="#搭建持续集成">搭建持续集成</a><ul>
<li><a href="#jenkins创建任务">Jenkins创建任务</a></li>
<li><a href="#创建shell">创建shell</a></li>
</ul></li>
</ul></li>
<li><a href="#更多功能">更多功能</a><ul>
<li><a href="#静态页面">静态页面</a><ul>
<li><a href="#安装-flatpages">安装 flatpages</a></li>
<li><a href="#创建模板">创建模板</a></li>
</ul></li>
<li><a href="#评论功能">评论功能</a></li>
<li><a href="#sitemap">Sitemap</a><ul>
<li><a href="#站点地图介绍">站点地图介绍</a></li>
<li><a href="#创建首页的sitemap">创建首页的Sitemap</a></li>
<li><a href="#创建静态页面的sitemap">创建静态页面的Sitemap</a></li>
<li><a href="#创建博客的sitemap">创建博客的Sitemap</a></li>
<li><a href="#提交到搜索引擎">提交到搜索引擎</a></li>
</ul></li>
</ul></li>
<li><a href="#前端框架">前端框架</a><ul>
<li><a href="#响应式设计">响应式设计</a><ul>
<li><a href="#引入前端框架">引入前端框架</a></li>
</ul></li>
<li><a href="#页面美化">页面美化</a><ul>
<li><a href="#添加导航">添加导航</a></li>
<li><a href="#添加标语">添加标语</a></li>
<li><a href="#优化列表">优化列表</a></li>
<li><a href="#添加footer">添加footer</a></li>
</ul></li>
</ul></li>
<li><a href="#api">API</a><ul>
<li><a href="#博客列表">博客列表</a><ul>
<li><a href="#django-rest-framework">Django REST Framework</a></li>
<li><a href="#创建博客列表api">创建博客列表API</a></li>
<li><a href="#测试-api">测试 API</a></li>
</ul></li>
<li><a href="#自动完成">自动完成</a><ul>
<li><a href="#搜索api">搜索API</a></li>
<li><a href="#页面实现">页面实现</a></li>
</ul></li>
<li><a href="#跨域支持">跨域支持</a><ul>
<li><a href="#cors">CORS</a></li>
<li><a href="#添加跨域支持">添加跨域支持</a></li>
</ul></li>
</ul></li>
<li><a href="#移动应用">移动应用</a><ul>
<li><a href="#helloworld">hello,world</a><ul>
<li><a href="#构建应用">构建应用</a></li>
</ul></li>
<li><a href="#博客列表页">博客列表页</a><ul>
<li><a href="#列表页">列表页</a></li>
<li><a href="#详情页">详情页</a></li>
</ul></li>
<li><a href="#profile">Profile</a><ul>
<li><a href="#json-web-tokens">Json Web Tokens</a></li>
<li><a href="#profile-1">Profile</a></li>
</ul></li>
<li><a href="#创建博客">创建博客</a></li>
<li><a href="#todo">TODO</a></li>
</ul></li>
<li><a href="#前端重构">前端重构</a><ul>
<li><a href="#mvvm">MVVM</a></li>
<li><a href="#ux">UX</a></li>
</ul></li>
<li><a href="#部署">部署</a><ul>
<li><a href="#配置管理">配置管理</a></li>
<li><a href="#fabric">Fabric</a></li>
</ul></li>
</ul>
</nav>
<h1 id="growth-in-action-django">Growth In Action Django</h1>
<h2 id="准备工作和工具">准备工作和工具</h2>
<p>在开始写代码之前你需要保证你有一些Python基础，如果没有的话，请参阅其他相关书籍来一起学习。</p>
<p>并且你还需要在你的计算机上安装：</p>
<ul>
<li>Python环境及其包管理工具pip。</li>
<li>Firefox浏览器——用于运行功能测试。</li>
<li>Git版本控制器——用于代码版本控制。</li>
<li>一个开发工具。（PS: 在这里笔者使用的是PyCharm的社区版）</li>
</ul>
<h1 id="深入浅出django">深入浅出Django</h1>
<h2 id="django简介">Django简介</h2>
<p>Django是一个高级的Python Web开发框架，它的目标是使得开发复杂的、数据库驱动的网站变得更加简单。</p>
<p>由于Django最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的。所以，我们可以发现在使用Django的很多网站里，都是用于作为CMS（内容管理系统）来使用的。使用Django的一些比较知名的网站如下图所示：</p>
<figure>
<img src="images/who-use-django.jpg" alt="使用Django的网站" /><figcaption>使用Django的网站</figcaption>
</figure>
<p>Django是一个MTV框架，其架构模板看上去与传统的MVC架构并没有太大的区别。其对比如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">传统的MVC架构</th>
<th style="text-align: left;">Django 架构</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Model</td>
<td style="text-align: left;">Model(Data Access Logic)</td>
</tr>
<tr class="even">
<td style="text-align: left;">View</td>
<td style="text-align: left;">Template(Presentation Logic)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">View</td>
<td style="text-align: left;">View(Business Logic)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Controller</td>
<td style="text-align: left;">Django itself</td>
</tr>
</tbody>
</table>
<p>在Django中View只用来描述你要看到的内容，Template才是最后用于显示的内容。而在MVC架构中，这只相当于是View层。它的核心包含下面的四部分：</p>
<ul>
<li>一个 对象关系映射，作为数据模型和关系性数据库间的媒介（Model层）；</li>
<li>一个基于正则表达式的URL分发器（即MVC中的Controller)；</li>
<li>一个用于处理HTTP请求的系统，含web模板系统(View层)；</li>
</ul>
<p>其核心框架还包含：</p>
<ul>
<li>一个轻量级的、独立的Web服务器，只用于开发和测试。</li>
<li>一个表单序列化及验证系统，用于将HTML表单转换成适用于数据库存储的数据。</li>
<li>一个缓存框架，并且可以从几种缓存方式中选择。</li>
<li>中间件支持，能对请求处理的各个阶段进行处理。</li>
<li>内置的分发系统允许应用程序中的组件采用预定义的信号进行相互间的通信。</li>
<li>一个序列化系统，能够生成或读取采用XML或JSON表示的Django模型实例。</li>
<li>一个用于扩展模板引擎的能力的系统。</li>
</ul>
<h3 id="django应用架构">Django应用架构</h3>
<p>Django的每一个模块在内部都称之为APP，在每个APP里都有自己的三层结构。如下图所示：</p>
<figure>
<img src="images/django_app_arch.jpg" alt="Django 应用架构" /><figcaption>Django 应用架构</figcaption>
</figure>
<p>这样做不仅可以在开发的时候更容易理解系统，而且可以提高代码的可复用性——因为每一个APP都是独立的应用，在下次使用时我们只需要简单的复制和粘贴。</p>
<p>说了这么多，还不如从一个hello,world开始。</p>
<h2 id="django-helloworld">Django hello,world</h2>
<h3 id="安装django">安装Django</h3>
<p>安装Django之前，我们可以用virtualenv工具来创建一个虚拟的Python运行环境。环境问题是一个很复杂的问题，在我们使用Python的过程中，我们会不断地安装一些库，而这些库可能会有不同的版本。并且在安装Python库的过程中，我们会遇到权限问题——即我们需要超级用户的权限才能将库安装到系统的环境之下。随后在这个软件的生涯中，我们还需要保证这个项目所依赖的模块不会发生变动。而这些都是很棘手的一些事，这时候我们就需要创建一个虚拟的运行环境，而virtualenv就是这样的一个工具。</p>
<h4 id="virtualenv">virtualenv</h4>
<p>安装Python包我们需要用到pip命令，它是Python语言中的一个包管理工具。如果你没有安装的话，可以使用下面的命令来安装：</p>
<pre><code>curl https://bootstrap.pypa.io/get-pip.py | python</code></pre>
<p>在不同的Python环境中，我们可能需要使用不同的pip，如下所示是笔者使用的Python3的pip命令pip3</p>
<pre><code>$ pip3 install virtualenv</code></pre>
<p>如果是Python2.7的话，对应会有:</p>
<pre><code>$ pip install virtualenv</code></pre>
<p>需要注意的是这将会安装到Python所在的目录，如我的目录是:</p>
<pre><code>$ /usr/local/bin/virtualenv</code></pre>
<p>有的可能会是：</p>
<pre><code>$ /usr/local/share/python3/virtualenv</code></pre>
<p>在创建我们的这个虚拟环境之前，我们可以创建一个存储所有virtualenv的目录：</p>
<pre><code>$ mkdir somewhere/virtualenvs</code></pre>
<p>现在，我们就可以创建一个新的虚拟环境：</p>
<pre><code>$ virtualenv somewhere/virtualenvs/&lt;project-name&gt; --no-site-packages</code></pre>
<p>如果你想使用不同的Python版本的话，那么需要指定Python版本的路径</p>
<pre><code>$ virtualenv --distribute -p /usr/local/bin/python3.3 somewhere/virtualenvs/&lt;project-name&gt;</code></pre>
<p>通过到相应的目录下执行激活就可以使用这个虚拟环境了：</p>
<pre><code>$ cd somewhere/virtualenvs/&lt;project-name&gt;/bin
$ source activate</code></pre>
<p>停止使用只使用执行下面的命令即可：</p>
<pre><code>$ deactivate</code></pre>
<h4 id="安装django-1">安装Django</h4>
<p>准备了这么久我们终于安装Django了，执行：</p>
<pre><code>$ pip install django</code></pre>
<p>那么我们并会开始下最新版本的Django，如下所示：</p>
<pre><code>Collecting django
  Downloading Django-1.9.4-py2.py3-none-any.whl (6.6MB)
    94% |██████████████████████████████▎ | 6.2MB 251kB/s eta 0:00:02</code></pre>
<p>等下载完后，就会开始安装Django。安装这完后，我们就可以使用Django自带的django-admin命令。django-admin是Django自带的一个管理任务的命令行工具。</p>
<p>通过这个命令，我们不仅仅可以用它来创建项目、创建app、运行服务、数据库迁移，还可以执行各种SQL工具等等。django-admin用法如下：</p>
<pre><code>$ django-admin &lt;command&gt; [options]</code></pre>
<p>下面是django-admin自带的一些命令：</p>
<pre><code>[django]
    check
    compilemessages
    createcachetable
    dbshell
    diffsettings
    dumpdata
    flush
    inspectdb
    loaddata
    makemessages
    makemigrations
    migrate
    runfcgi
    runserver
    shell
    sql
    sqlall
    sqlclear
    sqlcustom
    sqldropindexes
    sqlflush
    sqlindexes
    sqlinitialdata
    sqlmigrate
    sqlsequencereset
    squashmigrations
    startapp
    startproject
    syncdb
    test
    testserver
    validate</code></pre>
<p>现在，让我们来看看这个强大的工具。</p>
<h3 id="创建项目">创建项目</h3>
<p>在这些命令中startproject可以用于创建项目，在这里我们的项目名是blog，那么我们的命令如下：</p>
<p>$ django-admin startproject blog</p>
<p>这个命令将创建下面的文件内容，而这些是Django项目的一些必须文件。</p>
<pre><code>.
├── blog
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py</code></pre>
<p>blog目录对应的就是blog这个项目，将会放置这个项目的一些相关配置：</p>
<ol type="1">
<li>settings.py包含了这个项目的相关配置。如数据库环境、启用的插件等等。</li>
<li>urls.py即URL Dispatcher的配置，指明了某个URL应该指向某个函数来处理。</li>
<li>wsgi.py用于部署。WSGI（Python Web Server Gateway Interface，Web服务器网关接口）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。</li>
<li><strong>init</strong>.py指明了这是一个Python模块。</li>
</ol>
<p>manage.py 会在每个Django项目中自动生成，它可以和django-admin做类似的事。如我们可以用manage.py来启动测试环境的服务器：</p>
<p>$ python manage.py runserver</p>
<pre><code>Performing system checks...

System check identified no issues (0 silenced).

You have unapplied migrations; your app may not work properly until they are applied.
Run &#39;python manage.py migrate&#39; to apply them.

March 24, 2016 - 03:07:34
Django version 1.9.4, using settings &#39;blog.settings&#39;
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
Not Found: /
[24/Mar/2016 03:07:35] &quot;GET / HTTP/1.1&quot; 200 1767
Not Found: /favicon.ico
[24/Mar/2016 03:07:36] &quot;GET /favicon.ico HTTP/1.1&quot; 404 1934</code></pre>
<p>现在，我们只需要在浏览器中打开<a href="http://127.0.0.1:8000/" class="uri">http://127.0.0.1:8000/</a>，便可以访问我们的应用程序。</p>
<h3 id="django后台">Django后台</h3>
<p>Django很适合CMS的另外一个原因，就是它自带了一个后台管理系统。为了启用这个后台管理系统，我们需要配置我们的数据库，并创建相应的超级用户。如下所示的是settings.py中的默认数据库配置：</p>
<pre><code># Database
# https://docs.djangoproject.com/en/1.7/ref/settings/#databases

DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
}</code></pre>
<p>上面的配置中我们使用的是SQLite3作为数据库，并使用了当前目录下的<code>db.sqlite3</code>作为数据库文件。Django内建支持下面的一些数据库：</p>
<pre><code>&#39;django.db.backends.postgresql_psycopg2&#39;
&#39;django.db.backends.mysql&#39;
&#39;django.db.backends.sqlite3&#39;
&#39;django.db.backends.oracle&#39;</code></pre>
<p>如果我们想使用别的数据库，那么可以在网上寻找的解决方案，如用于支持使用MongoDB的django-nonrel项目。不同的数据库有不同的配置，如下所示的是使用PostgreSQL的配置。</p>
<pre><code>DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.postgresql_psycopg2&#39;,
        &#39;NAME&#39;: &#39;mydatabase&#39;,
        &#39;USER&#39;: &#39;mydatabaseuser&#39;,
        &#39;PASSWORD&#39;: &#39;mypassword&#39;,
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PORT&#39;: &#39;5432&#39;,
    }
}</code></pre>
<p>接着，我们就可以运行数据库迁移，只需要运行相应的脚本即可：</p>
<p>$ python manage.py migrate</p>
<pre><code>Operations to perform:
  Apply all migrations: sessions, admin, auth, contenttypes
Running migrations:
  Rendering model states... DONE
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying sessions.0001_initial... OK
(growth-django)</code></pre>
<p>在上面的过程中，我们会创建相应的数据库模型，并依据迁移脚本来创建一些相应的数据，如默认的配置等等。</p>
<p>最后，我们可以创建一个相应的超级用户来登陆后台。</p>
<p>$ python manage.py createsuperuser</p>
<pre><code>Username (leave blank to use &#39;fdhuang&#39;): root
Email address: h@phodal.com
Password:
Password (again):
Superuser created successfully.</code></pre>
<p>输入相应的用户名和密码，即可完成创建。然后访问 <a href="http://127.0.0.1:8000/admin" class="uri">http://127.0.0.1:8000/admin</a>，输入上面的用户名和密码就可以来到后台：</p>
<figure>
<img src="images/django-backend.jpg" alt="Django后台" /><figcaption>Django后台</figcaption>
</figure>
<h3 id="第一次提交">第一次提交</h3>
<p>在创建完应用后，我们就可以进行第一次提交，通常这样的提交的提交信息(commit message)是<code>init project</code>。如果在那之前，你没有执行<code>git init</code>来初始化git的话，那么我们就需要去执行这个命令。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> init</code></pre></div>
<p>它将返回类似于下面的结果</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Initialized</span> empty Git repository in /Users/fdhuang/test/helloworld/.git/</code></pre></div>
<p>即初始化了一个空的Git项目，然后我们就可以执行<code>add</code>来添加上面的内容：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> add .</code></pre></div>
<p>需要注意的是上在的数据库文件不应该添加到项目里，所以我们应该执行reset命令来重置这个状态：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> reset db.sqlite3</code></pre></div>
<p>这时我们会将其变成下面的状态：</p>
<figure>
<img src="images/first-commit.png" alt="第一次提交前的reset" /><figcaption>第一次提交前的reset</figcaption>
</figure>
<p>上面的绿色文件代码这几个文件都被添加了进行，蓝色则代表未添加的文件。为了避免手误产生一些问题，我们需要添加一个名为<code>.gitignore</code>文件用于将一些文件名入忽略名单，如下是常用的python项目的<code>.gitignore</code>文件中的内容：</p>
<pre><code>*.pyc
*.db
*.sqlite3</code></pre>
<p>当我们添加完这个文件完，git就会识别到这个文件，并忽略原来的那些文件，如下图所示：</p>
<figure>
<img src="images/git-ignore.png" alt="添加完gitignore文件后的效果" /><figcaption>添加完gitignore文件后的效果</figcaption>
</figure>
<p>我们只需要添加这个文件即可：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> add .gitignore</code></pre></div>
<p>如果你之前已经不小心添加了一些不应该添加的文件，那么可以执行下面的命令来重置其状态：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> reset .</code></pre></div>
<p>然后再执行添加命令。</p>
<p>最后，我们就可以在本地提交我们的代码了:</p>
<pre><code>git commit -m &quot;init project&quot;</code></pre>
<p>如果你是将代码托管在GitHub上的话，那么你就可以执行<code>git push</code>来将代码提交到服务器上。</p>
<h1 id="django创建博客应用">Django创建博客应用</h1>
<h2 id="tasking">Tasking</h2>
<p>在我们不了解Django的时候，要对这样一个任务进行Tasking，有点困难。不过，我们还是可以简单地看看是应该如何去做：</p>
<ul>
<li>生成APP。对于大部分主流的Web框架来说，它们都可以手动地生成一些脚手架，如Ruby语言中的Ruby On Rails、Node.js中的Express等等。</li>
<li>创建对应的Model，即其在数据库中存储的模型与我们在代码中要使用的模型。</li>
<li>创建程序对应的View，用于处理数据。</li>
<li>创建程序的Template，用于显示数据。</li>
<li>编写测试来保证功能。</li>
</ul>
<p>对于其他应用来说也是差不多的。</p>
<h2 id="创建blogpostapp">创建BlogpostAPP</h2>
<h3 id="生成app">生成APP</h3>
<p>现在我们可以开始创建我们的APP，使用下面的代码来创建：</p>
<p>$ django-admin startapp blogpost</p>
<p>会在blogpost目录下，生成下面的文件：</p>
<pre><code>.
├── __init__.py
├── admin.py
├── apps.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py</code></pre>
<h3 id="创建model">创建Model</h3>
<p>现在，我们需要来创建博客的Model即可。对于一篇基本的博客来说，它会包含下在面的几部分内容：</p>
<ul>
<li>标题</li>
<li>作者</li>
<li>链接（中文更需要一个好的链接）</li>
<li>内容</li>
<li>发布日期</li>
</ul>
<p>我们就可以按照上面的内容来创建我们的Blogpost model：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.db <span class="im">import</span> models
<span class="im">from</span> django.db.models <span class="im">import</span> permalink


<span class="kw">class</span> Blogpost(models.Model):
    title <span class="op">=</span> models.CharField(max_length<span class="op">=</span><span class="dv">100</span>, unique<span class="op">=</span><span class="va">True</span>)
    author <span class="op">=</span> models.CharField(max_length<span class="op">=</span><span class="dv">100</span>, unique<span class="op">=</span><span class="va">True</span>)
    slug <span class="op">=</span> models.SlugField(max_length<span class="op">=</span><span class="dv">100</span>, unique<span class="op">=</span><span class="va">True</span>)
    body <span class="op">=</span> models.TextField()
    posted <span class="op">=</span> models.DateField(db_index<span class="op">=</span><span class="va">True</span>, auto_now_add<span class="op">=</span><span class="va">True</span>)

    <span class="kw">def</span> <span class="fu">__unicode__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;</span><span class="sc">%s</span><span class="st">&#39;</span> <span class="op">%</span> <span class="va">self</span>.title

    <span class="at">@permalink</span>
    <span class="kw">def</span> get_absolute_url(<span class="va">self</span>):
        <span class="cf">return</span> (<span class="st">&#39;view_blog_post&#39;</span>, <span class="va">None</span>, { <span class="st">&#39;slug&#39;</span>: <span class="va">self</span>.slug })</code></pre></div>
<p>上面的<code>get_absolute_url</code>方法就是用于返回博客的链接。之所以使用手动而不是自动生成，是因为自动生成不靠谱，而且不利</p>
<p>然后在Admin注册这个Model</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.contrib <span class="im">import</span> admin
<span class="im">from</span> blogpost.models <span class="im">import</span> Blogpost

<span class="kw">class</span> BlogpostAdmin(admin.ModelAdmin):
    exclude <span class="op">=</span> [<span class="st">&#39;posted&#39;</span>]
    prepopulated_fields <span class="op">=</span> {<span class="st">&#39;slug&#39;</span>: (<span class="st">&#39;title&#39;</span>,)}

admin.site.register(Blogpost, BlogpostAdmin)</code></pre></div>
<p>接着进入后台，我们就可以看到BLOGPOST的一栏里，就可以对其进行相关的操作。</p>
<figure>
<img src="images/django-admin-ui.png" alt="Django后台界面" /><figcaption>Django后台界面</figcaption>
</figure>
<p>点击Blogpost的Add后，我们就会进入如下的添加博客界面：</p>
<figure>
<img src="images/admin-blog.png" alt="Django添加博客" /><figcaption>Django添加博客</figcaption>
</figure>
<p>实际上，这样做的意义是将删除(Delete)、修改(Update)、添加(Create)这些内容将给用户后台来做，当然它也不需要在View/Template层来做。在我们的Template层中，我们只需要关心如何来显示这些数据。</p>
<p>现在，我们可以执行一次新的代码提交——因为现在的代码可以正常工作。这样出现问题时，我们就可以即时的返回上一版本的代码。</p>
<pre><code>git add .
git commit -m &quot;create blogpost model&quot;</code></pre>
<p>然后再进行下一步地操作。</p>
<h3 id="配置url">配置URL</h3>
<p>现在，我们就可以在我们的<code>urls.py</code>里添加相应的route来访问页面，代码如下所示：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.conf <span class="im">import</span> settings
<span class="im">from</span> django.conf.urls <span class="im">import</span> patterns, include, url
<span class="im">from</span> django.conf.urls.static <span class="im">import</span> static
<span class="im">from</span> django.contrib <span class="im">import</span> admin

apiRouter <span class="op">=</span> routers.DefaultRouter()
apiRouter.register(<span class="vs">r&#39;blogpost&#39;</span>, BlogpostSet)

urlpatterns <span class="op">=</span> patterns(<span class="st">&#39;&#39;</span>,
    (<span class="vs">r&#39;^$&#39;</span>, <span class="st">&#39;blogpost.views.index&#39;</span>),
    url(<span class="vs">r&#39;^blog/(?P&lt;slug&gt;[^\.]+).html&#39;</span>, <span class="st">&#39;blogpost.views.view_post&#39;</span>, name<span class="op">=</span><span class="st">&#39;view_blog_post&#39;</span>),
    url(<span class="vs">r&#39;^admin/&#39;</span>, include(admin.site.urls))
) <span class="op">+</span> static(settings.STATIC_URL, document_root<span class="op">=</span>settings.STATIC_ROOT)</code></pre></div>
<p>在上面的代码里，我们创建了两个route：</p>
<ul>
<li>指向首页，其view是index</li>
<li>指向博客详情页，其view是view_post</li>
</ul>
<p>指向博客详情页的URL正规<code>r'^blog/(?P&lt;slug&gt;[^\.]+).html</code>，会将形如blog/hello-world.html中的hello-world提取出来作为参数传给view_post方法。</p>
<p>接着，我们就可以创建两个view。</p>
<h2 id="创建view">创建View</h2>
<h3 id="创建博客列表页">创建博客列表页</h3>
<p>对于我们的首页来说，我们可以简单的只显示五篇博客，所以我们所需要做的就是从我们的Blogpost对象中，取出前五个结果即可。代码如下所示：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.shortcuts <span class="im">import</span> render, render_to_response, get_object_or_404
<span class="im">from</span> blogpost.models <span class="im">import</span> Blogpost

<span class="kw">def</span> index(request):
    <span class="cf">return</span> render_to_response(<span class="st">&#39;index.html&#39;</span>, {
        <span class="st">&#39;posts&#39;</span>: Blogpost.objects.<span class="bu">all</span>()[:<span class="dv">5</span>]
    })</code></pre></div>
<p>Django的render_to_response方法可以根据一个给定的上下文字典渲染一个给定的目标，并返回渲染后的HttpResponse。即将相应的值，如这里的Blogpost.objects.all()[:5]，填入相应的index.html中，再返回最后的结果。</p>
<p>因此，在我们的index.html中，我们就可以拿到前五篇博客。我们只需要遍历出posts，拿出每个post相应的值，就可以完成列表页。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{% extends &#39;base.html&#39; %}
{% block title %}Welcome to my blog{% endblock %}

{% block content %}
<span class="kw">&lt;h1&gt;</span>Posts<span class="kw">&lt;/h1&gt;</span>
{% for post in posts %}
<span class="kw">&lt;h2&gt;&lt;a</span><span class="ot"> href=</span><span class="st">&quot;{{ post.get_absolute_url }}&quot;</span><span class="kw">&gt;</span>{{ post.title }}<span class="kw">&lt;/a&gt;&lt;/h2&gt;</span>
<span class="kw">&lt;p&gt;</span>{{post.posted}} - By {{post.author}}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;p&gt;</span>{{post.body}}<span class="kw">&lt;/p&gt;</span>
{% endfor %}
{% endblock %}</code></pre></div>
<p>在上面的模板里，我们还取出了博客的链接用于跳转到详情页。</p>
<h3 id="创建博客详情页">创建博客详情页</h3>
<p>依据上面拿到的slug，我们就可以创建对应的详情页的view，代码如下所示：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> view_post(request, slug):
    <span class="cf">return</span> render_to_response(<span class="st">&#39;blogpost_detail.html&#39;</span>, {
        <span class="st">&#39;post&#39;</span>: get_object_or_404(Blogpost, slug<span class="op">=</span>slug)
    })</code></pre></div>
<p>这里的<code>get_object_or_404</code>将会根据slug来获取相应的博客，如果取不出相应的博客就会返回404。因此，我们的详情页和上面的列表页也是类似的。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{% extends &#39;base.html&#39; %}
{% block head_title %}{{ post.title }}{% endblock %}
{% block title %}{{ post.title }}{% endblock %}

{% block content %}
<span class="kw">&lt;h2&gt;</span>{{ post.title }}<span class="kw">&lt;/a&gt;&lt;/h2&gt;</span>
<span class="kw">&lt;p&gt;</span>{{post.posted}} - By {{post.author}}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;p&gt;</span>{{post.body}}<span class="kw">&lt;/p&gt;</span>
{% endblock %}</code></pre></div>
<p>随后，我们就可以再提交一次代码了。</p>
<h2 id="测试">测试</h2>
<p>TDD虽然是一个非常好的实践，但是那是对于那些已经习惯写测试的人来说。如果你写测试的经历非常小，那么我们就可以从写测试开始。</p>
<p>在这里我们使用的是Django这个第三方框架来完成我们的工作，所以我们并不对这个框架的功能进行测试。虽然有些时候正是因为这些第三方框架的问题而导致的Bug，但是我们仅仅只是使用一些基础的功能。这些基础的功能也已经在他们的框架中测试过了。</p>
<h3 id="测试首页">测试首页</h3>
<p>先来做一个简单的测试，即测试我们访问首页的时候，调用的函数是上面的index函数</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.core.urlresolvers <span class="im">import</span> resolve
<span class="im">from</span> django.http <span class="im">import</span> HttpRequest
<span class="im">from</span> django.test <span class="im">import</span> TestCase

<span class="im">from</span> blogpost.views <span class="im">import</span> index, view_post


<span class="kw">class</span> HomePageTest(TestCase):
    <span class="kw">def</span> test_root_url_resolves_to_home_page_view(<span class="va">self</span>):
        found <span class="op">=</span> resolve(<span class="st">&#39;/&#39;</span>)
        <span class="va">self</span>.assertEqual(found.func, index)</code></pre></div>
<p>但是这样的测试看上去没有多大意义，不过它可以保证我们的route可以和我们的URL对应上。在编写完测试后，我们就可以命令提示行中运行:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">python</span> manage.py test</code></pre></div>
<p>来查看测试的结果：</p>
<pre><code>Creating test database for alias &#39;default&#39;...

.
----------------------------------------------------------------------
Ran 1 test in 0.031s

OK
Destroying test database for alias &#39;default&#39;...
(growth-django)</code></pre>
<p>运行通过，现在我们可以进行下一个测试了——我们可以测试页面的标题是不是我们想要的结果：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> test_home_page_returns_correct_html(<span class="va">self</span>):
        request <span class="op">=</span> HttpRequest()
        response <span class="op">=</span> index(request)
        <span class="va">self</span>.assertIn(b<span class="st">&#39;&lt;title&gt;Welcome to my blog&lt;/title&gt;&#39;</span>, response.content)</code></pre></div>
<p>这里我们需要去请求相应的页面来获取页面的标题，并用assertIn方法来断言返回的首页的html中含有<code>&lt;title&gt;Welcome to my blog&lt;/title&gt;</code>。</p>
<h3 id="测试详情页">测试详情页</h3>
<p>同样的我们也可以用测试是否调用某个函数的方法，来看博客的详情页的route是否正确？</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> BlogpostTest(TestCase):
    <span class="kw">def</span> test_blogpost_url_resolves_to_blog_post_view(<span class="va">self</span>):
        found <span class="op">=</span> resolve(<span class="st">&#39;/blog/this_is_a_test.html&#39;</span>)
        <span class="va">self</span>.assertEqual(found.func, view_post)</code></pre></div>
<p>与上面测试首页不一样的是，在我们的Blogpost测试中，我们需要创建数据，以确保这个流程是没有问题的。因此我们需要用<code>Blogpost.objects.create</code>方法来创建一个数据，然后访问相应的页面来看是否正确。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> test_blogpost_create_with_view(<span class="va">self</span>):
    Blogpost.objects.create(title<span class="op">=</span><span class="st">&#39;hello&#39;</span>, author<span class="op">=</span><span class="st">&#39;admin&#39;</span>, slug<span class="op">=</span><span class="st">&#39;this_is_a_test&#39;</span>, body<span class="op">=</span><span class="st">&#39;This is a blog&#39;</span>,
                            posted<span class="op">=</span>datetime.now)
    response <span class="op">=</span> <span class="va">self</span>.client.get(<span class="st">&#39;/blog/this_is_a_test.html&#39;</span>)
    <span class="va">self</span>.assertIn(b<span class="st">&#39;This is a blog&#39;</span>, response.content)</code></pre></div>
<p>或许你会疑惑这个数据会不会被注入到数据库中，请看运行测试时返回的结果的第一句：</p>
<pre><code>Creating test database for alias &#39;default&#39;...</code></pre>
<p>Django将会创建一个数据库用于测试。</p>
<p>同理，我们也可以为首页添加一个相似的测试：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> test_blogpost_create_with_show_in_homepage(<span class="va">self</span>):
    Blogpost.objects.create(title<span class="op">=</span><span class="st">&#39;hello&#39;</span>, author<span class="op">=</span><span class="st">&#39;admin&#39;</span>, slug<span class="op">=</span><span class="st">&#39;this_is_a_test&#39;</span>, body<span class="op">=</span><span class="st">&#39;This is a blog&#39;</span>,
                            posted<span class="op">=</span>datetime.now)
    response <span class="op">=</span> <span class="va">self</span>.client.get(<span class="st">&#39;/&#39;</span>)
    <span class="va">self</span>.assertIn(b<span class="st">&#39;This is a blog&#39;</span>, response.content)</code></pre></div>
<p>我们用同样的方法创建了一篇博客，然后在首页测试返回的内容中是否含有<code>This is a blog</code>。</p>
<h1 id="功能测试与持续集成">功能测试与持续集成</h1>
<p>在上一章最后，我们写的测试可以算得上是单元测试，接着我们可以写一些自动化测试。</p>
<h2 id="编写自动化测试">编写自动化测试</h2>
<p>接着我们就可以用Selenium来做自动化测试。这是ThoughtWorks出品的一个强大的基于浏览器的开源自动化测试工具，它通常用来编写Web 应用的自动化测试。</p>
<h3 id="selenium与第一个ui测试">Selenium与第一个UI测试</h3>
<p>先让我们来看一个自动化测试的例子：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.test <span class="im">import</span> LiveServerTestCase
<span class="im">from</span> selenium <span class="im">import</span> webdriver

<span class="kw">class</span> HomepageTestCase(LiveServerTestCase):
    <span class="kw">def</span> setUp(<span class="va">self</span>):
        <span class="va">self</span>.selenium <span class="op">=</span> webdriver.Firefox()
        <span class="va">self</span>.selenium.maximize_window()
        <span class="bu">super</span>(HomepageTestCase, <span class="va">self</span>).setUp()

    <span class="kw">def</span> tearDown(<span class="va">self</span>):
        <span class="va">self</span>.selenium.quit()
        <span class="bu">super</span>(HomepageTestCase, <span class="va">self</span>).tearDown()

    <span class="kw">def</span> test_visit_homepage(<span class="va">self</span>):
        <span class="va">self</span>.selenium.get(
            <span class="st">&#39;</span><span class="sc">%s%s</span><span class="st">&#39;</span> <span class="op">%</span> (<span class="va">self</span>.live_server_url,  <span class="st">&quot;/&quot;</span>)
        )

        <span class="va">self</span>.assertIn(<span class="st">&quot;Welcome to my blog&quot;</span>, <span class="va">self</span>.selenium.title)</code></pre></div>
<p>在setUp——即开始的时候，我们会用selenium起一个Firefox浏览器的进程，并执行maximize_window来将窗口最大化。在tearDown——即结束的时候，我们就会关闭这个浏览器的进程。我们的主要测试代码就在<code>test_visit_homepage</code>这个方法里，我们在里面访问首页，并判断标题是不是<code>Welcome to my blog</code>。</p>
<p>运行上面的测试就会启动一个浏览器，并且会在浏览器上进行相应的操作。如下图所示：</p>
<figure>
<img src="images/selenium-demo.jpg" alt="Selenium Demo" /><figcaption>Selenium Demo</figcaption>
</figure>
<p>这时你可能会产生一些疑惑，这些内容我们不是已经测试过了么？两者从测试看是差不多的，但是从流程上看来说并不是如些。下图是页面渲染的时间线：</p>
<figure>
<img src="images/page-timing-overview.png" alt="页面渲染时间线" /><figcaption>页面渲染时间线</figcaption>
</figure>
<p>请求从浏览器传到服务器要有一系列的过程，如重定向、缓存、DNS等等，最后直至返回对应的Response。我们用Django的测试框架只能实现到这一步，随后页面请请求对应的静态资料，再对页面进行渲染，在这个过程中页面的内容会发生一些变化。</p>
<p>为了避免页面的内容被替换掉，那么我们就需要对这部分内容进行测试。</p>
<p>如下的代码也是可以用于测试页面内容的代码：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> BlogpostDetailCase(LiveServerTestCase):
    <span class="kw">def</span> setUp(<span class="va">self</span>):
        Blogpost.objects.create(
            title<span class="op">=</span><span class="st">&#39;hello&#39;</span>,
            author<span class="op">=</span><span class="st">&#39;admin&#39;</span>,
            slug<span class="op">=</span><span class="st">&#39;this_is_a_test&#39;</span>,
            body<span class="op">=</span><span class="st">&#39;This is a blog&#39;</span>,
            posted<span class="op">=</span>datetime.now
        )

        <span class="va">self</span>.selenium <span class="op">=</span> webdriver.Firefox()
        <span class="va">self</span>.selenium.maximize_window()
        <span class="bu">super</span>(BlogpostDetailCase, <span class="va">self</span>).setUp()

    <span class="kw">def</span> tearDown(<span class="va">self</span>):
        <span class="va">self</span>.selenium.quit()
        <span class="bu">super</span>(BlogpostDetailCase, <span class="va">self</span>).tearDown()

    <span class="kw">def</span> test_visit_blog_post(<span class="va">self</span>):
        <span class="va">self</span>.selenium.get(
            <span class="st">&#39;</span><span class="sc">%s%s</span><span class="st">&#39;</span> <span class="op">%</span> (<span class="va">self</span>.live_server_url,  <span class="st">&quot;/blog/this_is_a_test.html&quot;</span>)
        )

        <span class="va">self</span>.assertIn(<span class="st">&quot;hello&quot;</span>, <span class="va">self</span>.selenium.title)</code></pre></div>
<p>虽然在这里我们要测试的只是页面的标题，而实际上我们要测试的是页面的元素是否存在。</p>
<p>同样的，我们也可以对博客的内容进行测试。这些稍有不同的是，我们更多地是要测试用户的行为，如我们在首页点击某个链接，那么我应该中转到对应的博客详情页，如下代码所示：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> BlogpostFromHomepageCase(LiveServerTestCase):
    <span class="kw">def</span> setUp(<span class="va">self</span>):
        Blogpost.objects.create(
            title<span class="op">=</span><span class="st">&#39;hello&#39;</span>,
            author<span class="op">=</span><span class="st">&#39;admin&#39;</span>,
            slug<span class="op">=</span><span class="st">&#39;this_is_a_test&#39;</span>,
            body<span class="op">=</span><span class="st">&#39;This is a blog&#39;</span>,
            posted<span class="op">=</span>datetime.now
        )

        <span class="va">self</span>.selenium <span class="op">=</span> webdriver.Firefox()
        <span class="va">self</span>.selenium.maximize_window()
        <span class="bu">super</span>(BlogpostFromHomepageCase, <span class="va">self</span>).setUp()

    <span class="kw">def</span> tearDown(<span class="va">self</span>):
        <span class="va">self</span>.selenium.quit()
        <span class="bu">super</span>(BlogpostFromHomepageCase, <span class="va">self</span>).tearDown()

    <span class="kw">def</span> test_visit_blog_post(<span class="va">self</span>):
        <span class="va">self</span>.selenium.get(
            <span class="st">&#39;</span><span class="sc">%s%s</span><span class="st">&#39;</span> <span class="op">%</span> (<span class="va">self</span>.live_server_url,  <span class="st">&quot;/&quot;</span>)
        )

        <span class="va">self</span>.selenium.find_element_by_link_text(<span class="st">&quot;hello&quot;</span>).click()
        <span class="va">self</span>.assertIn(<span class="st">&quot;hello&quot;</span>, <span class="va">self</span>.selenium.title)</code></pre></div>
<p>需要注意的是，如果我们的单元测试如果可以测试到页面的内容——即没有使用JavaScript对页面的内容进行修改，那么我们应该使用单元测试即可。如测试金字塔所说，越底层的测试越快。</p>
<p>在我们编写完这些测试后，我们就可以搭建好相应的持续集成来运行这些测试了。</p>
<h2 id="搭建持续集成">搭建持续集成</h2>
<p>这里我们将使用Jenkins来完成这部分的工具，它是一个用Java编写的开源的持续集成工具。</p>
<blockquote>
<p>它提供了软件开发的持续集成服务。它运行在Servlet容器中（例如Apache Tomcat）。它支持软件配置管理（SCM）工具（包括AccuRev SCM、CVS、Subversion、Git、Perforce、Clearcase和和RTC），可以执行基于Apache Ant和Apache Maven的项目，以及任意的Shell脚本和Windows批处理命令。</p>
</blockquote>
<p>要使用Jenkins，只需要从Jenkins的主页上(<a href="https://jenkins.io/" class="uri">https://jenkins.io/</a>)下载最新的 jenkins.war文件。然后运行</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">java</span> -jar jenkins.war</code></pre></div>
<p>便可以启动:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">Running</span> from: /Users/fdhuang/repractise/growth-ci/jenkins.war
<span class="kw">webroot</span>: <span class="ot">$user</span>.home/.jenkins
<span class="kw">May</span> 12, 2016 10:55:18 PM org.eclipse.jetty.util.log.JavaUtilLog info
<span class="kw">INFO</span>: Logging initialized @489ms
<span class="kw">May</span> 12, 2016 10:55:18 PM winstone.Logger logInternal
<span class="kw">INFO</span>: Beginning extraction from war file
<span class="kw">May</span> 12, 2016 10:55:20 PM org.eclipse.jetty.util.log.JavaUtilLog warn
<span class="kw">WARNING</span>: Empty contextPath
<span class="kw">May</span> 12, 2016 10:55:20 PM org.eclipse.jetty.util.log.JavaUtilLog info
<span class="kw">INFO</span>: jetty-9.2.z-SNAPSHOT
<span class="kw">May</span> 12, 2016 10:55:20 PM org.eclipse.jetty.util.log.JavaUtilLog info
<span class="kw">INFO</span>: NO JSP Support for /, did not find org.eclipse.jetty.jsp.JettyJspServlet
<span class="kw">Jenkins</span> home directory: /Users/fdhuang/.jenkins found at: <span class="ot">$user</span>.home/.jenkins
<span class="kw">May</span> 12, 2016 10:55:21 PM org.eclipse.jetty.util.log.JavaUtilLog info
<span class="kw">INFO</span>: Started w.@68c34b0<span class="dt">{/,file:/Users/fdhuang/.jenkins/war/,AVAILABLE}{/Users/fdhuang/.jenkins/war}</span>
<span class="kw">May</span> 12, 2016 10:55:21 PM org.eclipse.jetty.util.log.JavaUtilLog info
<span class="kw">INFO</span>: Started ServerConnector@733a9ac6<span class="dt">{HTTP/1.1}{0.0.0.0:8080}</span></code></pre></div>
<p>接着，打开<a href="http://0.0.0.0:8080/" class="uri">http://0.0.0.0:8080/</a>就可以进行后续的安装，如下图所示：</p>
<figure>
<img src="images/jenkins-install.jpg" alt="Jenkins安装过程" /><figcaption>Jenkins安装过程</figcaption>
</figure>
<p>慢慢等其安装完成：</p>
<figure>
<img src="images/jenkins-getting-started.jpg" alt="Jenkins安装完成" /><figcaption>Jenkins安装完成</figcaption>
</figure>
<p>等安装完成后，我们就可以开始使用Jenkins来创建我们的任务了。</p>
<h3 id="jenkins创建任务">Jenkins创建任务</h3>
<p>在首页，我们会看到“开始创建一个新任务”的提示，点击它。</p>
<p>源码管理中选择Git，并填入我们代码的地址：</p>
<pre><code>[https://github.com/phodal/growth-in-action-python-code](https://github.com/phodal/growth-in-action-python-code)</code></pre>
<p>如下图所示:</p>
<figure>
<img src="images/jenkins-repo-setup.jpg" alt="Jenkins设计Repo" /><figcaption>Jenkins设计Repo</figcaption>
</figure>
<p>然后就是构建触发器，一共有五种类型的触发器，意思也很容易理解：</p>
<ul>
<li>触发远程构建 (例如,使用脚本)</li>
<li>Build after other projects are built</li>
<li>Build periodically</li>
<li>Build when a change is pushed to GitHub</li>
<li>Poll SCM</li>
</ul>
<p>在这里，我们要使用的是GitHub这个，它的原理是:</p>
<blockquote>
<p>This job will be triggered if jenkins will receive PUSH GitHub hook from repo defined in scm section</p>
</blockquote>
<p>即Jenkins在监听GitHub上对应的PUSH hook，当发生代码提交时，就会运行我们的测试。</p>
<p>由于，我们暂时不需要一些特殊的<code>构建环境</code>配置，我们就可以将这个放空。接着，我们就可以配置<code>构建</code>了。</p>
<h3 id="创建shell">创建shell</h3>
<p>在这里我们需要添加的构建步骤是：<code>execute shell</code>，先让我们写一个简单的安装依赖的shell</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">virtualenv</span> --distribute -p /usr/local/bin/python3.5 growth-django
<span class="kw">source</span> growth-django/bin/activate
<span class="kw">pip</span> install -r requirements.txt</code></pre></div>
<p>然后在保存后，我们可以尝试立即构建这个项目：</p>
<figure>
<img src="images/build-console-ouput.jpg" alt="控制台输出" /><figcaption>控制台输出</figcaption>
</figure>
<p>在编写shell的过程中，我们要经过一些尝试，在这其中会经历一些失败的情形——即使是大部分有相关经验的程序员。如下图就是一次编写构建脚本引起的构建失败的例子：</p>
<figure>
<img src="images/jenkins-failure-setup.jpg" alt="Jenkins失败的构建" /><figcaption>Jenkins失败的构建</figcaption>
</figure>
<p>最后，我们就得到下面的一个shell脚本，我们就可以将其变成相应的运行CI的脚本。以便于它可以在其他环境中使用：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/usr/bin/env bash</span>
<span class="kw">virtualenv</span> --distribute -p /usr/local/bin/python3.5 growth-django
<span class="kw">source</span> growth-django/bin/activate
<span class="kw">pip</span> install -r requirements.txt
<span class="kw">python</span> manage.py test
<span class="kw">python</span> manage.py test test</code></pre></div>
<p>记得给你的shell文件，加上执行的标志：</p>
<pre><code>chmod u+x ./scripts/ci.sh</code></pre>
<p>最后，我们就可以修改CI上相应的构建环境的配置。</p>
<h1 id="更多功能">更多功能</h1>
<p>在Django框架中，内置了很多应用在它的“contrib”包中，这些包括：</p>
<ul>
<li>一个可扩展的认证系统</li>
<li>动态站点管理页面</li>
<li>一组产生RSS和Atom的工具</li>
<li>一个灵活的评论系统</li>
<li>产生Google站点地图（Google Sitemaps）的工具</li>
<li>防止跨站请求伪造（cross-site request forgery）的工具</li>
<li>一套支持轻量级标记语言（Textile和Markdown）的模板库</li>
<li>一套协助创建地理信息系统（GIS）的基础框架</li>
</ul>
<p>这意味着，我们可以直接用Django一些内置的组件来完成很多功能，先让我们来看看怎么完成一个简单的评论功能。</p>
<h2 id="静态页面">静态页面</h2>
<p>Django带有一个可选的“flatpages”应用，可以让我们存储简单的“扁平化(flat)”页面在数据库中，并且可以通过Django的管理界面以及一个Python API来处理要管理的内容。这样的一个静态页面，一般包含下面的几个属性：</p>
<ul>
<li>标题</li>
<li>URL</li>
<li>内容(Content)</li>
<li>Sites</li>
<li>自定义模板（可选）</li>
</ul>
<p>为了使用它来创建静态页面，我们需要在数据库中存储对应的映射关系，并创建对应的静态页面。</p>
<h3 id="安装-flatpages">安装 flatpages</h3>
<p>为此我们需要添加两个应用到<code>settings.py</code>文件的<code>INSTALLED_APPS</code>中：</p>
<ul>
<li><code>django.contrib.sites</code>——“sites”框架，它用于将对象和功能与特定的站点关联。同时，它还是域名和你的Django 站点名称之间的对应关系所保存的位置，即我们需要在这个地方设置我们的网站的域名。</li>
<li><code>django.contrib.flatpages</code>，即上文说到的内容。</li>
</ul>
<p>在添加<code>django.contrib.sites</code>的时候，我们需要创建一个<code>SITE_ID</code>。通过这个值等于1，除非我们打算用这个框架去管理多个站点。代码如下所示：</p>
<pre><code>SITE_ID = 1

INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;django.contrib.sites&#39;,
    &#39;django.contrib.flatpages&#39;,
    &#39;blogpost&#39;
)</code></pre>
<p>接着，还添加对应的中间件<code>django.contrib.flatpages.middleware.FlatpageFallbackMiddleware</code>到<code>settings.py</code>文件的<code>MIDDLEWARE_CLASSES</code>中。</p>
<p>然后，我们需要创建对应的URL来管理所有的静态页面。下面的代码是将静态页面都放在pages路径下，即如果我们有一个about的页面，那么的URL会变成 http://localhost/pages/about/。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">url(<span class="vs">r&#39;^pages/&#39;</span>, include(<span class="st">&#39;django.contrib.flatpages.urls&#39;</span>)),</code></pre></div>
<p>当然我们也可以将其配置为类似于 http://localhost/about/ 这样的URL：</p>
<pre><code>urlpatterns += [
    url(r&#39;^(?P&lt;url&gt;.*/)$&#39;, views.flatpage),
]</code></pre>
<p>最后，我们还需要做一个数据库迁移：</p>
<pre><code>Operations to perform:
  Apply all migrations: contenttypes, auth, admin, sites, blogpost, sessions, flatpages, django_comments
Running migrations:
  Rendering model states... DONE
  Applying flatpages.0001_initial... OK</code></pre>
<h3 id="创建模板">创建模板</h3>
<p>接着，我们可以在<code>templates</code>目录下创建<code>flatpages</code>文件，用于存放我们的模板文件，下面是一个简单的模板：</p>
<pre><code>{% extends &#39;base.html&#39; %}
{% block title %}关于我{% endblock %}

{% block content %}
&lt;div&gt;
&lt;h2&gt;关于博客&lt;/h2&gt;
    &lt;p&gt;一方面，找到更多志同道合的人；另一方面，扩大影响力。&lt;/p&gt;
    &lt;p&gt;内容包括&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;成长记录&lt;/li&gt;
        &lt;li&gt;技术笔记&lt;/li&gt;
        &lt;li&gt;生活思考&lt;/li&gt;
        &lt;li&gt;个人试验&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
{% endblock %}</code></pre>
<p>当我们完成模板后，我们就需要登录后台，并添加对应的静态页面的配置：</p>
<figure>
<img src="images/admin-flatpages-create.jpg" alt="管理员界面创建flatpage" /><figcaption>管理员界面创建flatpage</figcaption>
</figure>
<p>然后从高级选项中填写我们的静态页面的路径，我们就可以完成静态页面的创建。如下图所示：</p>
<figure>
<img src="images/flatpages-advance-option.png" alt="flatpage高级选项" /><figcaption>flatpage高级选项</figcaption>
</figure>
<p>最后，还要所个链接加到首页的导航中：</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;li&gt;</span>
    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/pages/resume/&quot;</span><span class="kw">&gt;</span>简历<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/li&gt;</span></code></pre></div>
<p>下面让我们为我们的博客添加一个简单的评论功能吧！</p>
<h2 id="评论功能">评论功能</h2>
<p>在早期的Django版本(1.6以前)中，Comments是自带的组件，但是后来它被从标准组件中移除了。因此，我们需要安装comments这个包：</p>
<pre><code>pip install django-contrib-comments</code></pre>
<p>再把它及它的版本添加到<code>requirements.txt</code>，如下所示：</p>
<pre><code>django==1.9.4
selenium==2.53.1
fabric==1.10.2
djangorestframework==3.3.3
djangorestframework-jwt==1.7.2
django-cors-headers==1.1.0
django-contrib-comments==1.7.1</code></pre>
<p>接着，将<code>django.contrib.sites</code>和<code>django_comments</code>添加到<code>INSTALLED_APPS</code>，如下:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">INSTALLED_APPS <span class="op">=</span> (
    <span class="st">&#39;django.contrib.admin&#39;</span>,
    <span class="co">&#39;django.contrib.auth&#39;</span>,
    <span class="co">&#39;django.contrib.contenttypes&#39;</span>,
    <span class="co">&#39;django.contrib.sessions&#39;</span>,
    <span class="co">&#39;django.contrib.messages&#39;</span>,
    <span class="co">&#39;django.contrib.staticfiles&#39;</span>,
    <span class="co">&#39;django.contrib.sites&#39;</span>,
    <span class="co">&#39;django_comments&#39;</span>,
    <span class="co">&#39;rest_framework&#39;</span>,
    <span class="co">&#39;blogpost&#39;</span>
)</code></pre></div>
<p>然后做一下数据库迁移我们就可以完成对其的初始化：</p>
<pre><code>Operations to perform:
  Apply all migrations: contenttypes, admin, blogpost, auth, sites, sessions, django_comments
Running migrations:
  Rendering model states... DONE
  Applying sites.0001_initial... OK
  Applying django_comments.0001_initial... OK
  Applying django_comments.0002_update_user_email_field_length... OK
  Applying django_comments.0003_add_submit_date_index... OK
  Applying sites.0002_alter_domain_unique... OK
(growth-django)</code></pre>
<p>然后再添加URL到urls.py:</p>
<pre><code>url(r&#39;^comments/&#39;, include(&#39;django_comments.urls&#39;)),</code></pre>
<p>现在，我们就可以登录后台，来创建对应的评论，但是这是时候评论是不会显示到页面上的。所以我们需要对我们的博客详情页的模板进行修改，在其中添加一句:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{% render_comment_list for post %}</code></pre></div>
<p>用于显示对应博客的评论，最近我们的模板文件如下面的内容所示：</p>
<pre><code>{% extends &#39;base.html&#39; %}
{% load comments %}

{% block head_title %}{{ post.title }}{% endblock %}
{% block title %}{{ post.title }}{% endblock %}

{% block content %}
&lt;div class=&quot;mdl-card mdl-shadow--2dp&quot;&gt;
    &lt;div class=&quot;mdl-card__title&quot;&gt;
        &lt;h2 class=&quot;mdl-card__title-text&quot;&gt;&lt;a href=&quot;{{ post.get_absolute_url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class=&quot;mdl-card__supporting-text&quot;&gt;
        {{post.body}}
    &lt;/div&gt;
    &lt;div class=&quot;mdl-card__actions&quot;&gt;
        {{post.posted}} - By {{post.author}}
    &lt;/div&gt;
&lt;/div&gt;

{% render_comment_list for post %}

{% endblock %}</code></pre>
<p>遗憾的是，当我们刷新页面的时候，页面报错了，原因如下所示：</p>
<figure>
<img src="images/site_id_issue.jpg" alt="SITE_ID报错" /><figcaption>SITE_ID报错</figcaption>
</figure>
<p>我们还需要定义一个<code>SITE_ID</code>，添加下面的代码到<code>settings.py</code>文件中即可：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">SITE_ID <span class="op">=</span> <span class="dv">1</span></code></pre></div>
<p>然后，我们就可以从后台创建评论：</p>
<figure>
<img src="images/create-comment-backend.jpg" alt="后台创建评论" /><figcaption>后台创建评论</figcaption>
</figure>
<h2 id="sitemap">Sitemap</h2>
<p>我们在之前的文章中提到过SEO的重要性，这里只是简单地对Sitemap的内容进行展开。</p>
<h3 id="站点地图介绍">站点地图介绍</h3>
<p>Sitemap译为站点地图，它用于告诉搜索引擎他们网站上有哪些可供抓取的网页。常见的Sitemap的形式是以xml出现了，如下是我博客的sitemap.xml的一部分内容：</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;urlset</span><span class="ot"> xmlns=</span><span class="st">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;url&gt;</span>
  <span class="kw">&lt;loc&gt;</span>https://www.phodal.com/blog/mezzanine-add-new-page/<span class="kw">&lt;/loc&gt;</span>
  <span class="kw">&lt;lastmod&gt;</span>2014-08-03<span class="kw">&lt;/lastmod&gt;</span>
  <span class="kw">&lt;changefreq&gt;</span>Monthly<span class="kw">&lt;/changefreq&gt;</span>
  <span class="kw">&lt;priority&gt;</span>0.2<span class="kw">&lt;/priority&gt;</span>
<span class="kw">&lt;/url&gt;</span>
<span class="kw">&lt;/urlset&gt;</span></code></pre></div>
<p>从上面的内容中，我们可以发现它包含了下面的一些XML标签：</p>
<ul>
<li>urlset，封装该文件，并指明当前协议的标准。</li>
<li>url，每个URL实体的父标签。</li>
<li>loc，指明页面的URL</li>
<li>lastmod（可选），内容最后的修改时间</li>
<li>changefreq（可选），内容的修改频率，用于告知搜索引擎抓取频率。它包含的值有：<code>always</code>、<code>hourly</code>、<code>daily</code>、<code>weekly</code>、<code>monthly</code>、<code>yearly</code>、<code>never</code></li>
<li>priority（可选），范围是从0.0~1.0，搜索引擎用于对你网站在搜索结果的排序，即内部的优先级排序。需要注意的是如果你把所有页面的优先级设置为1，那么它就和没有设置的效果是一样的。</li>
</ul>
<p>从上面的内容中，我们可以发现：</p>
<blockquote>
<p>站点地图能够提供与其中列出的网页相关的宝贵元数据：元数据是网页的相关信息，例如网页的最近更新时间、网页的更改频率以及网页相较于网站中其他网址的重要程度。 ——内容来自 Google Sitemap帮助文档。</p>
</blockquote>
<p>现在，我们一共有三种类型的页面：</p>
<ul>
<li>首页，通常来说首页的priority应该是最高的，而它的<code>changefreq</code>可以设置为<code>daily</code>、<code>weekly</code>，这取决于你的博客的更新频率。如果你是做一些UGC(用户生成内容)的网站，那么你应该设置为<code>always</code>、<code>hourly</code>。</li>
<li>动态生成的博客详情页，这些内容一般很少进行改变，所以这的changefreq会比较低，如<code>yearly</code>或者<code>monthly</code>——并且没有高的必要性，它会导致搜索引擎一直抓取你的内容。这会对服务器造成一定的压力，并且无助于你网站的排名。</li>
<li>静态页面，如About页面，它可以有一个高的<code>priority</code>，但是它的<code>changefreq</code>也不一定很高。</li>
</ul>
<p>下面就让我们从首页说起。</p>
<h3 id="创建首页的sitemap">创建首页的Sitemap</h3>
<p>与上面创建静态页面时一样，我们也需要添加<code>django.contrib.sitemaps</code>到<code>INSTALLED_APPS</code>中。</p>
<p>然后，我们需要指定一个URL规则。通常来说，这个URL是叫sitemap.xml——一个约定俗成的标准。我们需要创建一个sitemaps对象来存储所有的sitemaps:</p>
<pre><code>url(r&#39;^sitemap\.xml$&#39;, sitemap, {&#39;sitemaps&#39;: sitemaps}, name=&#39;django.contrib.sitemaps.views.sitemap&#39;)</code></pre>
<p>因此，我们需要创建几种不同类型的sitemap，如下是首页的Sitemap，它继承自Django的Sitemap类：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> PageSitemap(Sitemap):
    priority <span class="op">=</span> <span class="fl">1.0</span>
    changefreq <span class="op">=</span> <span class="st">&#39;daily&#39;</span>

    <span class="kw">def</span> items(<span class="va">self</span>):
        <span class="cf">return</span> [<span class="st">&#39;main&#39;</span>]

    <span class="kw">def</span> location(<span class="va">self</span>, item):
        <span class="cf">return</span> reverse(item)</code></pre></div>
<p>它定义了自己的priority是最高的1.0，同时每新频率为<code>daily</code>。然后在items里面去取它所要获取的URL，即<code>urls.py</code>中对应的<code>name</code>的<code>main</code>的URL。在这里我们只返回了<code>main</code>一个值，依据于下面的location方法中的<code>reverse</code>，它找到了main对应的URL，即首页。</p>
<p>最后结合首页sitemap.xml的<code>urls.py</code>代码如下所示：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sitemap.sitemaps <span class="im">import</span> PageSitemap

sitemaps <span class="op">=</span>  {
    <span class="st">&quot;page&quot;</span>: PageSitemap
}

urlpatterns <span class="op">=</span> patterns(<span class="st">&#39;&#39;</span>,
    url(<span class="vs">r&#39;^$&#39;</span>, blogpostViews.index, name<span class="op">=</span><span class="st">&#39;main&#39;</span>),
    url(<span class="vs">r&#39;^blog/(?P&lt;slug&gt;[^\.]+).html&#39;</span>, <span class="st">&#39;blogpost.views.view_post&#39;</span>, name<span class="op">=</span><span class="st">&#39;view_blog_post&#39;</span>),
    url(<span class="vs">r&#39;^comments/&#39;</span>, include(<span class="st">&#39;django_comments.urls&#39;</span>)),
    url(<span class="vs">r&#39;^admin/&#39;</span>, include(admin.site.urls)),
    url(<span class="vs">r&#39;^pages/&#39;</span>, include(<span class="st">&#39;django.contrib.flatpages.urls&#39;</span>)),
    url(<span class="vs">r&#39;^sitemap\.xml$&#39;</span>, sitemap, {<span class="st">&#39;sitemaps&#39;</span>: sitemaps}, name<span class="op">=</span><span class="st">&#39;django.contrib.sitemaps.views.sitemap&#39;</span>)
) <span class="op">+</span> static(settings.STATIC_URL, document_root<span class="op">=</span>settings.STATIC_ROOT)</code></pre></div>
<p>除此，我们还需要创建自己的<code>sitemap.xml</code>模板——自带的系统模板比较简单。</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;urlset</span><span class="ot"> xmlns=</span><span class="st">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span><span class="kw">&gt;</span>
{% spaceless %}
{% for url in urlset %}
<span class="kw">&lt;url&gt;</span>
    <span class="kw">&lt;loc&gt;</span>{{ url.location }}<span class="kw">&lt;/loc&gt;</span>
    {% if url.lastmod %}<span class="kw">&lt;lastmod&gt;</span>{{ url.lastmod|date:&quot;Y-m-d&quot; }}<span class="kw">&lt;/lastmod&gt;</span>{% endif %}
    {% if url.changefreq %}<span class="kw">&lt;changefreq&gt;</span>{{ url.changefreq }}<span class="kw">&lt;/changefreq&gt;</span>{% endif %}
    {% if url.priority %}<span class="kw">&lt;priority&gt;</span>{{ url.priority }}<span class="kw">&lt;/priority&gt;</span>{% endif %}
<span class="kw">&lt;/url&gt;</span>
{% endfor %}
{% endspaceless %}
<span class="kw">&lt;/urlset&gt;</span></code></pre></div>
<p>最后，我们访问<a href="http://localhost:8000/sitemap.xml" class="uri">http://localhost:8000/sitemap.xml</a>，我们就可以获取到我们的<code>sitemap.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;
    &lt;url&gt;
        &lt;loc&gt;http://www.phodal.com/&lt;/loc&gt;
        &lt;changefreq&gt;daily&lt;/changefreq&gt;
        &lt;priority&gt;1.0&lt;/priority&gt;
    &lt;/url&gt;
&lt;/urlset&gt;</code></pre>
<p>下一步，我们仍可以直接创建出对应的静态页面的Sitemap。</p>
<h3 id="创建静态页面的sitemap">创建静态页面的Sitemap</h3>
<p>相似的，我们也需要从items访法中，定义出我们所要创建页面的对象。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> django.contrib.sitemaps <span class="im">import</span> Sitemap
<span class="im">from</span> django.core.urlresolvers <span class="im">import</span> reverse
<span class="im">from</span> django.apps <span class="im">import</span> apps <span class="im">as</span> django_apps

<span class="kw">class</span> FlatPageSitemap(Sitemap):
    priority <span class="op">=</span> <span class="fl">0.8</span>

    <span class="kw">def</span> items(<span class="va">self</span>):
        Site <span class="op">=</span> django_apps.get_model(<span class="st">&#39;sites.Site&#39;</span>)
        current_site <span class="op">=</span> Site.objects.get_current()
        <span class="cf">return</span> current_site.flatpage_set.<span class="bu">filter</span>(registration_required<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<p>只不过这个方法可能会稍微麻烦一些，我们需要从数据库中取中当前的站点。再取出当前站点中的flatpage集合，对过滤出那些不需要注册的页面，即代码中的<code>registration_required=False</code>。</p>
<p>最近再将这个对象放入sitemaps即可：</p>
<pre><code>from sitemap.sitemaps import PageSitemap, FlatPageSitemap

sitemaps =  {
    &quot;page&quot;: PageSitemap,
    &#39;flatpages&#39;: FlatPageSitemap
}</code></pre>
<p>现在，我们可以完成博客的Sitemap了。</p>
<h3 id="创建博客的sitemap">创建博客的Sitemap</h3>
<p>同上面一样的是，我们依然需要在items方法中返回所有的博客内容。并且在lastmod中，返回这篇博客的发表日期——以免他们返回的是同一个日期：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> BlogSitemap(Sitemap):
    changefreq <span class="op">=</span> <span class="st">&quot;never&quot;</span>
    priority <span class="op">=</span> <span class="fl">0.5</span>

    <span class="kw">def</span> items(<span class="va">self</span>):
        <span class="cf">return</span> Blogpost.objects.<span class="bu">all</span>()

    <span class="kw">def</span> lastmod(<span class="va">self</span>, obj):
        <span class="cf">return</span> obj.posted</code></pre></div>
<p>最近我们的Sitemap.xml，如下所示:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;urlset</span><span class="ot"> xmlns=</span><span class="st">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;url&gt;</span>
        <span class="kw">&lt;loc&gt;</span>http://www.phodal.com/about/<span class="kw">&lt;/loc&gt;</span>
        <span class="kw">&lt;priority&gt;</span>0.8<span class="kw">&lt;/priority&gt;</span>
    <span class="kw">&lt;/url&gt;</span>
    <span class="kw">&lt;url&gt;</span>
        <span class="kw">&lt;loc&gt;</span>http://www.phodal.com/<span class="kw">&lt;/loc&gt;</span>
        <span class="kw">&lt;changefreq&gt;</span>daily<span class="kw">&lt;/changefreq&gt;</span>
        <span class="kw">&lt;priority&gt;</span>1.0<span class="kw">&lt;/priority&gt;</span>
    <span class="kw">&lt;/url&gt;</span>
    <span class="kw">&lt;url&gt;</span>
        <span class="kw">&lt;loc&gt;</span>http://www.phodal.com/blog/hello.html<span class="kw">&lt;/loc&gt;</span>
        <span class="kw">&lt;lastmod&gt;</span>2016-03-24<span class="kw">&lt;/lastmod&gt;</span>
        <span class="kw">&lt;changefreq&gt;</span>never<span class="kw">&lt;/changefreq&gt;</span>
        <span class="kw">&lt;priority&gt;</span>0.5<span class="kw">&lt;/priority&gt;</span>
    <span class="kw">&lt;/url&gt;</span>
<span class="kw">&lt;/urlset&gt;</span></code></pre></div>
<h3 id="提交到搜索引擎">提交到搜索引擎</h3>
<p>这里我们以Google Webmaster为例简单的介绍一下如何使用各种站长工具来提交sitemap.xml。</p>
<p>我们可以登录Google的Webmaster：<a href="https://www.google.com/webmasters/tools/home?hl=zh-cn" class="uri">https://www.google.com/webmasters/tools/home?hl=zh-cn</a>，然后点击添加属性来创建一个新的网站:</p>
<figure>
<img src="images/add-property.png" alt="添加网站" /><figcaption>添加网站</figcaption>
</figure>
<p>这时候Google需要确认这个网站是你的，所以它提供几点方法来验证，除了下面的推荐方法：</p>
<figure>
<img src="images/google-add-website.png" alt="推荐的验证方式" /><figcaption>推荐的验证方式</figcaption>
</figure>
<p>我们可以使用下面的这一些方法：</p>
<figure>
<img src="images/google-addition-method.png" alt="备选的难方法" /><figcaption>备选的难方法</figcaption>
</figure>
<p>我个人比较喜欢用HTML Tag的方式来实现</p>
<figure>
<img src="images/html-tag.png" alt="HTML标签验证" /><figcaption>HTML标签验证</figcaption>
</figure>
<p>在我们完成验证之后，我们就可以在后台手动提交Sitemap.xml了。</p>
<figure>
<img src="images/google-add-sitemap.png" alt="提交Sitemap.xml" /><figcaption>提交Sitemap.xml</figcaption>
</figure>
<p>点击上方的<strong>添加/测试站点地图</strong>即可。</p>
<h1 id="前端框架">前端框架</h1>
<p>我们的前端样式实在是太丑了，让我们想办法来美化一下它们吧——这时候我们就需要一个前端框架来帮助我们做这件事。这里的前端框架并不是指那种MV*框架，而是UI框架。</p>
<h2 id="响应式设计">响应式设计</h2>
<p>考虑到易学程度，以其响应式设计的问题，我们决定用Bootstrap来作为这里的前端框架。Bootstrap是Twitter推出的一个用于前端开发的开源工具包，似乎也是当前“最受欢迎”的前端框架。它提供了全面、美观的文档。你能在这里找到关于 HTML 元素、HTML 和 CSS 组件、jQuery 插件方面的所有详细文档。并且我们能在 Bootstrap 的帮助下通过同一份代码快速、有效适配手机、平板、PC 设备。</p>
<p>它是一个支持响应式设计的框架，即页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。如下图所示：</p>
<figure>
<img src="images/responsive-design.png" alt="响应式设计" /><figcaption>响应式设计</figcaption>
</figure>
<p>我们在不同的设计上看到的是不是同的布局，这会依据我们的设备大小做出调整——使用媒体查询(media queries)实现。</p>
<h3 id="引入前端框架">引入前端框架</h3>
<p>下好Bootstrap，将里面的内容复制到<code>static/</code>目录，如下所示：</p>
<pre><code>.
├── css
│   ├── bootstrap-theme.css
│   ├── bootstrap-theme.css.map
│   ├── bootstrap-theme.min.css
│   ├── bootstrap-theme.min.css.map
│   ├── bootstrap.css
│   ├── bootstrap.css.map
│   ├── bootstrap.min.css
│   ├── bootstrap.min.css.map
│   └── styles.css
├── fonts
│   ├── glyphicons-halflings-regular.eot
│   ├── glyphicons-halflings-regular.svg
│   ├── glyphicons-halflings-regular.ttf
│   ├── glyphicons-halflings-regular.woff
│   └── glyphicons-halflings-regular.woff2
└── js
    ├── bootstrap.js
    ├── bootstrap.min.js
    └── npm.js</code></pre>
<p>它包含了JavaScript、CSS还有字体，需要注意的一点是bootstrap依赖于jquery。因此，我们需要下载jquery并放到这个目录里。然后在我们的head里引入这些css</p>
<pre><code>&lt;head&gt;
    &lt;title&gt;{% block head_title %}Welcome to my blog{% endblock %}&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static &#39;css/bootstrap.min.css&#39; %}&quot;&gt;
&lt;/head&gt;</code></pre>
<p>在我们的body结尾的地方：</p>
<pre><code>&lt;script src=&quot;{% static &#39;js/jquery.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;js/bootstrap.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>在这里，将Script放在body的尾部有利于用户打开页面的速度。而对于一些纯前端的框架来说，它们就需要放在页面开始的地方。</p>
<h2 id="页面美化">页面美化</h2>
<p>现在，我们就可以创建一个导航了。</p>
<h3 id="添加导航">添加导航</h3>
<p>根据Bootstrap的官方文档的Demo，我们可以创建对应的导航。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;header</span><span class="ot"> class=</span><span class="st">&quot;navbar navbar-static-top bs-docs-nav&quot;</span><span class="ot"> id=</span><span class="st">&quot;top&quot;</span><span class="ot"> role=</span><span class="st">&quot;banner&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;container&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;navbar-header&quot;</span><span class="kw">&gt;</span>
            <span class="kw">&lt;button</span><span class="ot"> class=</span><span class="st">&quot;navbar-toggle collapsed&quot;</span><span class="ot"> type=</span><span class="st">&quot;button&quot;</span><span class="ot"> data-toggle=</span><span class="st">&quot;collapse&quot;</span>
<span class="ot">                    data-target=</span><span class="st">&quot;.bs-navbar-collapse&quot;</span><span class="kw">&gt;</span>
                <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;sr-only&quot;</span><span class="kw">&gt;</span>切换视图<span class="kw">&lt;/span&gt;</span>
                <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;icon-bar&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
                <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;icon-bar&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
                <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;icon-bar&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
            <span class="kw">&lt;/button&gt;</span>
            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/&quot;</span><span class="ot"> class=</span><span class="st">&quot;navbar-brand&quot;</span><span class="kw">&gt;</span>Growth博客<span class="kw">&lt;/a&gt;</span>
        <span class="kw">&lt;/div&gt;</span>
        <span class="kw">&lt;nav</span><span class="ot"> class=</span><span class="st">&quot;collapse navbar-collapse bs-navbar-collapse&quot;</span><span class="ot"> role=</span><span class="st">&quot;navigation&quot;</span><span class="kw">&gt;</span>
            <span class="kw">&lt;ul</span><span class="ot"> class=</span><span class="st">&quot;nav navbar-nav&quot;</span><span class="kw">&gt;</span>
                <span class="kw">&lt;li&gt;</span>
                    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/pages/about/&quot;</span><span class="kw">&gt;</span>关于我<span class="kw">&lt;/a&gt;</span>
                <span class="kw">&lt;/li&gt;</span>
                <span class="kw">&lt;li&gt;</span>
                    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/pages/resume/&quot;</span><span class="kw">&gt;</span>简历<span class="kw">&lt;/a&gt;</span>
                <span class="kw">&lt;/li&gt;</span>
            <span class="kw">&lt;/ul&gt;</span>
            <span class="kw">&lt;ul</span><span class="ot"> class=</span><span class="st">&quot;nav navbar-nav navbar-right&quot;</span><span class="kw">&gt;</span>
                <span class="kw">&lt;li&gt;&lt;a</span><span class="ot"> href=</span><span class="st">&quot;/admin&quot;</span><span class="ot"> id=</span><span class="st">&quot;loginLink&quot;</span><span class="kw">&gt;</span>登入<span class="kw">&lt;/a&gt;&lt;/li&gt;</span>
            <span class="kw">&lt;/ul&gt;</span>

        <span class="kw">&lt;/nav&gt;</span>
    <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/header&gt;</span></code></pre></div>
<p>它在桌面下的效果大致如下图所示：</p>
<figure>
<img src="images/bootstrap-nav-desktop.png" alt="桌面浏览器下的Bootstrap导航" /><figcaption>桌面浏览器下的Bootstrap导航</figcaption>
</figure>
<p>而在移动浏览器下则是这样的效果：</p>
<figure>
<img src="images/nav-in-mobile.png" alt="移动设备上的导航" /><figcaption>移动设备上的导航</figcaption>
</figure>
<p>当我们点击右上角的菜单按钮时，会出现我们的菜单</p>
<figure>
<img src="images/nav-in-mobile-with-click.png" alt="点击导航后的结果" /><figcaption>点击导航后的结果</figcaption>
</figure>
<h3 id="添加标语">添加标语</h3>
<p>接着，我们可以快速的创建一个标语：</p>
<pre><code>&lt;main class=&quot;bs-docs-masthead&quot; id=&quot;content&quot; role=&quot;main&quot;&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div id=&quot;carbonads-container&quot;&gt;
            THE ONLY FAIR IS NOT FAIR &lt;br&gt;
            ENJOY CREATE &amp; SHARE
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/main&gt;</code></pre>
<p>这里的代码都比较简单，我想也不需要太多的解释。</p>
<h3 id="优化列表">优化列表</h3>
<p>接着，我们可以简单的对首页的博客列表做一个优化，方法比较简单：</p>
<ul>
<li>为博客列表添加一个<code>row</code>的class，表示它可以滚动</li>
<li>在每一篇博客里添加<code>col-sm-4</code>的class，在不同的大小下会有不同的布局</li>
</ul>
<p>代码如下所示：</p>
<pre><code>{% extends &#39;base.html&#39; %}
{% block title %}Welcome to my blog{% endblock %}

{% block content %}
&lt;h2&gt;博客&lt;/h2&gt;
&lt;div class=&quot;row&quot;&gt;
    {% if posts %}
    {% for post in posts %}
    &lt;div class=&quot;col-sm-4&quot;&gt;
        &lt;h2&gt;&lt;a href=&quot;{{ post.get_absolute_url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/h2&gt;
        {{post.body | slice:&quot;:80&quot;}}
        {{post.posted}} - By {{post.author}}
    &lt;/div&gt;
    {% endfor %}
    {% else %}
    &lt;p&gt;There are no posts.&lt;/p&gt;
    {% endif %}
&lt;/div&gt;
{% endblock %}</code></pre>
<p>它在桌面和自动设备上的效果如下图所示：</p>
<figure>
<img src="images/desktop-blogposts.png" alt="桌面设备效果" /><figcaption>桌面设备效果</figcaption>
</figure>
<figure>
<img src="images/mobile-blogposts.png" alt="移动设备效果" /><figcaption>移动设备效果</figcaption>
</figure>
<h3 id="添加footer">添加footer</h3>
<p>最后，我们可以在页面的最下方添加一个footer，来做一些版权声明：</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;footer</span><span class="ot"> class=</span><span class="st">&quot;footer&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;container&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">&quot;text-muted&quot;</span><span class="kw">&gt;</span>@Copyright Phodal.com<span class="kw">&lt;/p&gt;</span>
    <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/footer&gt;</span></code></pre></div>
<p>它拥有一些简单的样式，来将footer固定在页面的最下方：</p>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fl">.footer</span> <span class="kw">{</span>
  <span class="kw">position:</span> <span class="dt">absolute</span><span class="kw">;</span>
  <span class="kw">bottom:</span> <span class="dt">0</span><span class="kw">;</span>
  <span class="kw">width:</span> <span class="dt">100%</span><span class="kw">;</span>
  <span class="co">/* Set the fixed height of the footer here */</span>
  <span class="kw">height:</span> <span class="dt">60px</span><span class="kw">;</span>
  <span class="kw">background-color:</span> <span class="dt">#f5f5f5</span><span class="kw">;</span>
<span class="kw">}</span>
<span class="fl">.footer</span> <span class="fl">.container</span> <span class="kw">{</span>
  <span class="kw">width:</span> <span class="dt">auto</span><span class="kw">;</span>
  <span class="kw">max-width:</span> <span class="dt">680px</span><span class="kw">;</span>
  <span class="kw">padding:</span> <span class="dt">0</span> <span class="dt">15px</span><span class="kw">;</span>
<span class="kw">}</span>

<span class="fl">.footer</span> <span class="fl">.container</span> <span class="fl">.text-muted</span> <span class="kw">{</span>
  <span class="kw">margin:</span> <span class="dt">20px</span> <span class="dt">0</span><span class="kw">;</span>
<span class="kw">}</span></code></pre></div>
<h1 id="api">API</h1>
<p>在下一章开始之前，我们先来搭建一下API平台，不仅仅可以提供一些额外的功能，还可以为我们的APP提供API。</p>
<h2 id="博客列表">博客列表</h2>
<h3 id="django-rest-framework">Django REST Framework</h3>
<p>在这里，我们需要用到一个名为Django REST Framework的RESTful API库。通过这个库，我们可以快速创建我们所需要的API。</p>
<p>Django REST Framework 这个名字很直白，就是基于 Django 的 REST 框架。因此，首先我们仍是要安装这个库：</p>
<pre><code>pip install djangorestframework</code></pre>
<p>然后把它添加到<code>INSTALLED_APPS</code>中：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">INSTALLED_APPS <span class="op">=</span> (
    ...
    <span class="st">&#39;rest_framework&#39;</span>,
)</code></pre></div>
<p>如下所示：</p>
<pre><code>INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;rest_framework&#39;,
    &#39;blogpost&#39;
)</code></pre>
<p>接着我们可以在我们的API中创建一个URL，用于匹配它的授权机制。</p>
<pre><code>urlpatterns = [
    ...
    url(r&#39;^api-auth/&#39;, include(&#39;rest_framework.urls&#39;, namespace=&#39;rest_framework&#39;))
]</code></pre>
<p>不过这个API，目前并没有多大的用途。只有当我们在制作一些需要权限验证的接口时，它才会突显它的重要性。</p>
<h3 id="创建博客列表api">创建博客列表API</h3>
<p>为了方便我们继续展开后面的内容，我们先来创建一个博客列表API。参考Django REST Framework的官方文档，我们可以很快地创建出下面的Demo:</p>
<pre><code>from django.contrib.auth.models import User
from rest_framework import serializers, viewsets
from blogpost.models import Blogpost


class BlogpsotSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Blogpost
        fields = (&#39;title&#39;, &#39;author&#39;, &#39;body&#39;, &#39;slug&#39;)

class BlogpostSet(viewsets.ModelViewSet):
    queryset = Blogpost.objects.all()
    serializer_class = BlogpsotSerializer</code></pre>
<p>在上面这个例子中，API由两个部分组成：</p>
<ul>
<li>ViewSets，用于定义视图的展现形式——如返回哪些内容，需要做哪些权限处理</li>
<li>Serializers，用于定义API的表现形式——如返回哪些字段，返回怎样的格式</li>
</ul>
<p>我们在我们的URL中，会定义相应的规则到ViewSet，而ViewSet则通过<code>serializer_class</code>找到对应的<code>Serializers</code>。我们将Blogpost的所有对象赋予queryset，并返回这些值。在BlogpsotSerializer中，我们定义了我们要返回的几个字段：<code>title</code>、<code>author</code>、<code>body</code>、<code>slug</code>。</p>
<p>接着，我们可以在我们的<code>urls.py</code>配置URL。</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">...

<span class="im">from</span> rest_framework <span class="im">import</span> routers
<span class="im">from</span> blogpost.api <span class="im">import</span> BlogpostSet

apiRouter <span class="op">=</span> routers.DefaultRouter()
apiRouter.register(<span class="vs">r&#39;blogpost&#39;</span>, BlogpostSet)

urlpatterns <span class="op">=</span> patterns(<span class="st">&#39;&#39;</span>,
    ...
    url(<span class="vs">r&#39;^api/&#39;</span>, include(apiRouter.urls)),
) <span class="op">+</span> static(settings.STATIC_URL, document_root<span class="op">=</span>settings.STATIC_ROOT)</code></pre></div>
<p>我们使用默认的Router来配置我们的URL，即DefaultRouter，它提供了一个非常简单的机制来自动检测URL规则。因此，我们只需要注册好我们的url——<code>blogpost</code>以及它值<code>BlogpostSet</code>即可。随后，我们再为其定义一个根URL即可:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">url(<span class="vs">r&#39;^api/&#39;</span>, include(apiRouter.urls))</code></pre></div>
<h3 id="测试-api">测试 API</h3>
<p>现在，我们可以访问<a href="http://127.0.0.1:8000/api/" class="uri">http://127.0.0.1:8000/api/</a>来访问我们现在的API。由于Django REST Framework提供了一个UI机制，所以我们可以在网页上直接看到我们所有的API：</p>
<figure>
<img src="images/django-rest-framework-api-lists.png" alt="Django REST Framework列表" /><figcaption>Django REST Framework列表</figcaption>
</figure>
<p>然后，点击页面中的<a href="http://127.0.0.1:8000/api/blogpost/" class="uri">http://127.0.0.1:8000/api/blogpost/</a>，我们就可以访问博客相关的API了，如下图所示:</p>
<figure>
<img src="images/drf-blogppost-set-list.png" alt="博客API" /><figcaption>博客API</figcaption>
</figure>
<p>在页面上显示了所有的博客内容，在页面的下面有一个表单可以先让我们来创建数据：</p>
<figure>
<img src="images/api-post-form.png" alt="创建博客的表单" /><figcaption>创建博客的表单</figcaption>
</figure>
<p>直接在表单中添加数据，我们就可以完成数据创建了。</p>
<p>当然，我们也可以直接用命令行工具来测试，执行：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">curl</span> -i  http://127.0.0.1:8000/api/blogpost/</code></pre></div>
<p>即可返回相应的结果：</p>
<figure>
<img src="images/curl-api.png" alt="CuRL API" /><figcaption>CuRL API</figcaption>
</figure>
<h2 id="自动完成">自动完成</h2>
<p>AutoComplete是一个很有意思的功能，特别是当我们的文章很多的时候，我们可以让读者有机会能搜索到相应的功能。以Google为例，Google在我们输入一些关键字的时候，会向我们推荐一些比较流行的词条可以让我们选择。</p>
<figure>
<img src="images/google-autocomplete.png" alt="Google AutoComplete" /><figcaption>Google AutoComplete</figcaption>
</figure>
<p>同样的，我们也可以实现一个同样的效果用于我们的博客搜索：</p>
<figure>
<img src="images/autocomplete-example.png" alt="自动完成" /><figcaption>自动完成</figcaption>
</figure>
<p>当我们输入某一些关键字的时候，就会出现文章的标题，随后我们只需要点击相应的标题即可跳转到文章。</p>
<h3 id="搜索api">搜索API</h3>
<p>为了实现这个功能我们需要对之前的博客API做一些简单的改造——可以支持搜索博客标题。这里我们需要稍微扩展一下我们的博客API即可：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> BlogpostSet(viewsets.ModelViewSet):
    permission_classes <span class="op">=</span> (permissions.IsAuthenticatedOrReadOnly,)
    serializer_class <span class="op">=</span> BlogpsotSerializer
    search_fields <span class="op">=</span> <span class="st">&#39;title&#39;</span>

    <span class="kw">def</span> <span class="bu">list</span>(<span class="va">self</span>, request):
        queryset <span class="op">=</span> Blogpost.objects.<span class="bu">all</span>()

        search_param <span class="op">=</span> <span class="va">self</span>.request.query_params.get(<span class="st">&#39;title&#39;</span>, <span class="va">None</span>)
        <span class="cf">if</span> search_param <span class="op">is</span> <span class="op">not</span> <span class="va">None</span>:
            queryset <span class="op">=</span> Blogpost.objects.<span class="bu">filter</span>(title__contains<span class="op">=</span>search_param)

        serializer <span class="op">=</span> BlogpsotSerializer(queryset, many<span class="op">=</span><span class="va">True</span>)
        <span class="cf">return</span> Response(serializer.data)</code></pre></div>
<p>我们添加了一个名为<code>search_fields</code>的变量，顾名思义就是定义搜索字段。接着我们覆写了ModelViewSet的list方法，它是用于列出(list)所有的结果。我们会尝试在我们的请求中获取搜索参量，如果没有的话我们就返回所有的结果。如果搜索的参数中含有标题，则从所有博客中过滤出标题中含有搜索标题中的内容，再返回这些结果。如下是一个搜索的URL：<a href="http://127.0.0.1:8000/api/blogpost/?format=json&amp;title=test" class="uri">http://127.0.0.1:8000/api/blogpost/?format=json&amp;title=test</a>，我们搜索标题中含有<code>test</code>的内容。</p>
<p>同时，我们还需要为我们的apiRouter设置一个basename，即下面代码中最后的<code>Blogpost</code></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">apiRouter.register(<span class="vs">r&#39;blogpost&#39;</span>, BlogpostSet, <span class="st">&#39;Blogpost&#39;</span>)</code></pre></div>
<h3 id="页面实现">页面实现</h3>
<p>接着，我们就可以在页面上实现这个功能。在这里我们使用一个名为<a href="https://github.com/bassjobsen/Bootstrap-3-Typeahead">Bootstrap-3-Typeahead</a>的插件来实现，下载这个插件以及它对应的CSS：<a href="https://github.com/bassjobsen/typeahead.js-bootstrap-css" class="uri">https://github.com/bassjobsen/typeahead.js-bootstrap-css</a>，并添加到<code>base.html</code>中，然后创建一个<code>main.js</code>文件负责相关的逻辑处理。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;{% static &#39;js/jquery.min.js&#39; %}&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;{% static &#39;js/bootstrap.min.js&#39; %}&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;{% static &#39;js/bootstrap3-typeahead.min.js&#39; %}&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;{% static &#39;js/main.js&#39; %}&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></code></pre></div>
<h2 id="跨域支持">跨域支持</h2>
<h3 id="cors">CORS</h3>
<h3 id="添加跨域支持">添加跨域支持</h3>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install django-cors-headers</code></pre></div>
<pre><code>Collecting django-cors-headers
  Downloading django-cors-headers-1.1.0.tar.gz
Building wheels for collected packages: django-cors-headers
  Running setup.py bdist_wheel for django-cors-headers ... done
  Stored in directory: /Users/fdhuang/Library/Caches/pip/wheels/b0/75/89/7b17f134fc01b74e10523f3128e45b917da0c5f8638213e073
Successfully built django-cors-headers
Installing collected packages: django-cors-headers
Successfully installed django-cors-headers-1.1.0</code></pre>
<p>添加到<code>django-cors-headers=1.1.0</code>到<code>requirements.txt</code>文件中。</p>
<p>添加到<code>settings.py</code>中：</p>
<pre><code>INSTALLED_APPS = (
    ...
    &#39;corsheaders&#39;,
    ...
)</code></pre>
<p>以及对应的中间件：</p>
<pre><code>MIDDLEWARE_CLASSES = (
    ...
    &#39;corsheaders.middleware.CorsMiddleware&#39;,
    &#39;django.middleware.common.CommonMiddleware&#39;,
    ...
)</code></pre>
<p>对应的配置：</p>
<pre><code>CORS_ALLOW_CREDENTIALS = True</code></pre>
<h1 id="移动应用">移动应用</h1>
<p>依靠习惯我们还将用Ionic 2继续创建hello,world。</p>
<h2 id="helloworld">hello,world</h2>
<p>开始之前我们需要先安装Ionic的命令行工具，后来我们需要用这个工具来创建工程。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">npm</span> install -g ionic@beta</code></pre></div>
<p>如果没有意外，我们将安装成功，然后可以使用<code>ionic</code>命令:</p>
<p>它自带了一系列的工具来加速我们的开发，这些工具可以在后面的章节中学习到。</p>
<pre><code>Available tasks: (use --help or -h for more info)

   start  ..........  Starts a new Ionic project in the specified PATH
   serve  ..........  Start a local development server for app dev/testing
   platform  .......  Add platform target for building an Ionic app
   run  ............  Run an Ionic project on a connected device
   emulate  ........  Emulate an Ionic project on a simulator or emulator
   build  ..........  Build (prepare + compile) an Ionic project for a given platform.

   plugin  .........  Add a Cordova plugin
   resources  ......  Automatically create icon and splash screen resources (beta)
              Put your images in the ./resources directory, named splash or icon.
              Accepted file types are .png, .ai, and .psd.
              Icons should be 192x192 px without rounded corners.
              Splashscreens should be 2208x2208 px, with the image centered in the middle.

   upload  .........  Upload an app to your Ionic account
   share  ..........  Share an app with a client, co-worker, friend, or customer
   lib  ............  Gets Ionic library version or updates the Ionic library
   setup  ..........  Configure the project with a build tool (beta)
   io  .............  Integrate your app with the ionic.io platform services (alpha)
   security  .......  Store your app&#39;s credentials for the Ionic Platform (alpha)
   push  ...........  Upload APNS and GCM credentials to Ionic Push (alpha)
   package  ........  Use Ionic Package to build your app (alpha)
   config  .........  Set configuration variables for your ionic app (alpha)
   browser  ........  Add another browser for a platform (beta)
   service  ........  Add an Ionic service package and install any required plugins
   add  ............  Add an Ion, bower component, or addon to the project
   remove  .........  Remove an Ion, bower component, or addon from the project
   list  ...........  List Ions, bower components, or addons in the project
   info  ...........  List information about the users runtime environment
   help  ...........  Provides help for a certain command
   link  ...........  Sets your Ionic App ID for your project
   hooks  ..........  Manage your Ionic Cordova hooks
   state  ..........  Saves or restores state of your Ionic Application using the package.json file
   docs  ...........  Opens up the documentation for Ionic
   generate  .......  Generate pages and components</code></pre>
<p>现在，我们就可以用第一个命令<code>start</code>来创建我们的项目。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ionic</span> start growth-blog-app --v2</code></pre></div>
<p>在这个过程中，它将下载Ionic 2项目的基础项目，并执行安装命令。</p>
<pre><code>Creating Ionic app in folder /Users/fdhuang/repractise/growth-blog-app based on tabs project
Downloading: https://github.com/driftyco/ionic2-app-base/archive/master.zip
[=============================]  100%  0.0s
Downloading: https://github.com/driftyco/ionic2-starter-tabs/archive/master.zip
[=============================]  100%  0.0s
Installing npm packages...</code></pre>
<p>然后到<code>growth-blog-app</code>目录，我们会看到类似于下面的内容：</p>
<pre><code>.
├── README.md
├── app
│   ├── app.js
│   ├── pages
│   │   ├── page1
│   │   │   ├── page1.html
│   │   │   ├── page1.js
│   │   │   └── page1.scss
│   │   ├── page2
│   │   │   ├── page2.html
│   │   │   ├── page2.js
│   │   │   └── page2.scss
│   │   ├── page3
│   │   │   ├── page3.html
│   │   │   ├── page3.js
│   │   │   └── page3.scss
│   │   └── tabs
│   │       ├── tabs.html
│   │       └── tabs.js
│   └── theme
│       ├── app.core.scss
│       ├── app.ios.scss
│       ├── app.md.scss
│       ├── app.variables.scss
│       └── app.wp.scss
├── config.xml
├── gulpfile.js
├── hooks
│   ├── README.md
│   └── after_prepare
│       └── 010_add_platform_class.js
├── ionic.config.json
├── package.json
└── www
    └── index.html</code></pre>
<p>在这2.0版本的Ionic，页面开始以目录来划分，一个页面路径下有自己的<code>html</code>、<code>js</code>、<code>scss</code>。</p>
<ul>
<li><code>tabs</code>负责这些页面间跳转</li>
<li><code>theme</code>则负责系统相应样式的修改</li>
<li><code>config.xml</code>带有相应的Cordova配置</li>
<li><code>hooks</code>则对系统添加和编译时进行一些预处理</li>
<li><code>ionic.config.json</code>则是ionic的一些相关配置选项</li>
<li><code>package.json</code>则存放相应的node.js的包的依赖</li>
<li><code>www</code>目录用于存放出最后构建出来的内容，以及一些静态资源</li>
</ul>
<p>由于Angular 2.0使用的是Typescript，所以在这里我们将用typescript进行展示，因此我们的执行命令变成~~：</p>
<pre><code>ionic start growth-blog-app --v2 --ts</code></pre>
<p><code>--ts</code>表示使用的是<code>typescript</code>来创建项目，安装的过程是一样的，不一样的是后面写的代码。</p>
<p>执行相应的起serve命令，我们就可以开始我们的项目了：</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ionic</span> serve</code></pre></div>
<p>这时候Ionic将做一些额外的事，才能启动我们的服务，如：</p>
<ul>
<li>删除<code>www/build</code>目录下的文件</li>
<li>编译SASS到CSS</li>
<li>编译文件到HTML</li>
<li>编译字体</li>
<li>等等</li>
</ul>
<p>最后，它将启动一个Web服务，URL为<a href="http://localhost:8100" class="uri">http://localhost:8100</a></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">  <span class="kw">Running</span> <span class="st">&#39;serve:before&#39;</span> gulp task before serve
  [<span class="kw">20</span>:59:16] Starting <span class="st">&#39;clean&#39;</span>...
  [<span class="kw">20</span>:59:16] Finished <span class="st">&#39;clean&#39;</span> after 6.07 ms
  [<span class="kw">20</span>:59:16] Starting <span class="st">&#39;watch&#39;</span>...
  [<span class="kw">20</span>:59:16] Starting <span class="st">&#39;sass&#39;</span>...
  [<span class="kw">20</span>:59:16] Starting <span class="st">&#39;html&#39;</span>...
  [<span class="kw">20</span>:59:16] Starting <span class="st">&#39;fonts&#39;</span>...
  [<span class="kw">20</span>:59:16] Starting <span class="st">&#39;scripts&#39;</span>...
  [<span class="kw">20</span>:59:16] Finished <span class="st">&#39;scripts&#39;</span> after 43 ms
  [<span class="kw">20</span>:59:16] Finished <span class="st">&#39;html&#39;</span> after 51 ms
  [<span class="kw">20</span>:59:16] Finished <span class="st">&#39;fonts&#39;</span> after 54 ms
  [<span class="kw">20</span>:59:16] Finished <span class="st">&#39;sass&#39;</span> after 738 ms
  <span class="kw">7.6</span> MB bytes written (5.62 seconds)
  [<span class="kw">20</span>:59:22] Finished <span class="st">&#39;watch&#39;</span> after 6.62 s
  [<span class="kw">20</span>:59:22] Starting <span class="st">&#39;serve:before&#39;</span>...
  [<span class="kw">20</span>:59:22] Finished <span class="st">&#39;serve:before&#39;</span> after 3.87 μs

  <span class="kw">Running</span> live reload server: http://localhost:35729
  <span class="kw">Watching</span>: www/**/*, !www/lib/**/*
  √ <span class="kw">Running</span> dev server:  http://localhost:8100
  <span class="kw">Ionic</span> server commands, enter:
    <span class="kw">restart</span> or r to restart the client app from the root
    <span class="kw">goto</span> or g and a url to have the app navigate to the given url
    <span class="kw">consolelogs</span> or c to enable/disable console log output
    <span class="kw">serverlogs</span> or s to enable/disable server log output
    <span class="kw">quit</span> or q to shutdown the server and exit
  <span class="kw">ionic</span> $</code></pre></div>
<p>接着，就可以打开相应的Web页面，如下图所示：</p>
<figure>
<img src="./images/ionic-web-view.jpg" alt="Ionic Web预览界面" /><figcaption>Ionic Web预览界面</figcaption>
</figure>
<h3 id="构建应用">构建应用</h3>
<p>由于Ionic是基于Cordova的，我们需要安装Cordova业完成后续的工作。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sudo</span> npm install -g cordova</code></pre></div>
<p>为了构建不同的平台的应用，我们就需要添加不同的平台，如:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ionic</span> platform add android</code></pre></div>
<p>上面的命令可以为项目添加Android平台的支持，过程如下面的日志所示：</p>
<pre><code>Adding android project...
Creating Cordova project for the Android platform:
    Path: platforms/android
    Package: io.ionic.starter
    Name: V2_Test
    Activity: MainActivity
    Android target: android-23
Android project created with cordova-android@5.1.1
Running command: /Users/fdhuang/repractise/growth-blog-app/hooks/after_prepare/010_add_platform_class.js /Users/fdhuang/repractise/growth-blog-app</code></pre>
<p>最近，再执行<code>run</code>就可以在对应的平台上运行，如:</p>
<pre><code>ionic run android</code></pre>
<h2 id="博客列表页">博客列表页</h2>
<p>现在，让我们来结合我们的博客APP，做一个相应的展示博客的APP。</p>
<h3 id="列表页">列表页</h3>
<p>在上一个章节里我们已经有了一个博客详细的API，我们只需要获取这个API并显示即可。不过，让我们简单地熟悉一下显示数据的这部分内容：</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ion-navbar</span> <span class="er">*navbar</span><span class="kw">&gt;</span>
  <span class="kw">&lt;ion-title&gt;</span>博客<span class="kw">&lt;/ion-title&gt;</span>
<span class="kw">&lt;/ion-navbar&gt;</span>

<span class="kw">&lt;ion-content</span><span class="ot"> class=</span><span class="st">&quot;blog-list&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;ion-item</span> <span class="er">*ngFor</span><span class="ot">=</span><span class="st">&quot;#blogpost of blogposts&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;h1</span> <span class="er">*ngIf</span><span class="ot">=</span><span class="st">&quot;blogpost&quot;</span><span class="kw">&gt;</span>
      {{blogpost.title}}
    <span class="kw">&lt;/h1&gt;</span>

    <span class="kw">&lt;p</span> <span class="er">*ngIf</span><span class="ot">=</span><span class="st">&quot;blogpost&quot;</span><span class="kw">&gt;</span>
      {{blogpost.body}}
    <span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/ion-item&gt;</span>
<span class="kw">&lt;/ion-content&gt;</span></code></pre></div>
<p>上面是一个基本的详情页的模板，其中定义了一系列的Ionic自定义标签，如：</p>
<ul>
<li><ion-navbar> 显示在导航栏中的内容</li>
<li><ion-content> 显示APP的内容</li>
<li><ion-item> 即将博客成每一项</li>
</ul>
<p>而从上面的内容中，我们可以看到：我们在ngFor中遍历了blogposts，然后显示每篇文章的标题和内容。对应的代码也就比较简单了:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span>Page<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;ionic-angular&#39;</span><span class="op">;</span>

@<span class="at">Page</span>(<span class="op">{</span>
  <span class="dt">templateUrl</span><span class="op">:</span> <span class="st">&#39;build/pages/blog/list/index.html&#39;</span><span class="op">,</span>
  <span class="dt">providers</span><span class="op">:</span> [BlogpostServices]
<span class="op">}</span>)
<span class="im">export</span> <span class="kw">class</span> BlogList <span class="op">{</span>
  <span class="kw">public</span> blogposts<span class="op">;</span>

  <span class="at">constructor</span>() <span class="op">{</span>

  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>但是我们要去哪里获取博客的值呢，先我们我们看完改造后听BlogList的Controller：</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span>Page<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;ionic-angular&#39;</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span>BlogpostServices<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;../../../services/BlogpostServices&#39;</span><span class="op">;</span>

@<span class="at">Page</span>(<span class="op">{</span>
  <span class="dt">templateUrl</span><span class="op">:</span> <span class="st">&#39;build/pages/blog/list/index.html&#39;</span><span class="op">,</span>
  <span class="dt">providers</span><span class="op">:</span> [BlogpostServices]
<span class="op">}</span>)
<span class="im">export</span> <span class="kw">class</span> BlogList <span class="op">{</span>
  <span class="kw">private</span> blogListService<span class="op">;</span>
  <span class="kw">public</span> blogposts<span class="op">;</span>

  <span class="at">constructor</span>(<span class="dt">blogpostServices</span><span class="op">:</span>BlogpostServices) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">blogListService</span> <span class="op">=</span> blogpostServices<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">initService</span>()<span class="op">;</span>
  <span class="op">}</span>

  <span class="kw">private</span> <span class="at">initService</span>() <span class="op">{</span>
    <span class="kw">this</span>.<span class="va">blogListService</span>.<span class="at">getBlogpostLists</span>().<span class="at">subscribe</span>(
      data <span class="op">=&gt;</span> <span class="op">{</span><span class="kw">this</span>.<span class="at">blogposts</span> <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">data</span>.<span class="at">_body</span>)<span class="op">;},</span>
      err <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Error: &#39;</span> <span class="op">+</span> <span class="va">JSON</span>.<span class="at">stringify</span>(err))<span class="op">,</span>
      () <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Get Blogpost&#39;</span>)
    )<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>我们初始化了一个blogListService，然后我们调用这个服务去获取博客列表。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">    <span class="kw">this</span>.<span class="va">blogListService</span>.<span class="at">getBlogpostLists</span>().<span class="at">subscribe</span>(
      data <span class="op">=&gt;</span> <span class="op">{</span><span class="kw">this</span>.<span class="at">blogposts</span> <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">data</span>.<span class="at">_body</span>)<span class="op">;},</span>
      err <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Error: &#39;</span> <span class="op">+</span> <span class="va">JSON</span>.<span class="at">stringify</span>(err))<span class="op">,</span>
      () <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Get Blogpost&#39;</span>)
    )<span class="op">;</span></code></pre></div>
<p>当我们获取到数据的时候，我们就解析这个数据，并将这个值赋予blogposts。如果这其中遇到什么错误，就会显示相应的错误信息。</p>
<p>现在，让我们创建一个获取博客的服务：</p>
<pre><code>import {Inject} from &#39;angular2/core&#39;;
import {Http} from &#39;angular2/http&#39;;
import &#39;rxjs/add/operator/map&#39;;

export class BlogpostServices {
  private http;

  constructor(@Inject(Http) http:Http) {
    this.http = http
  }

  getBlogpostLists() {
    var url = &#39;http://127.0.0.1:8000/api/blogpost/?format=json&#39;;
    return this.http.get(url).map(res =&gt; res);
  }
}</code></pre>
<h3 id="详情页">详情页</h3>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ionic</span> g page blog-detail --ts</code></pre></div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">app/pages/blog-detail/</span>
├── <span class="kw">blog-detail.html</span>
├── <span class="kw">blog-detail.ts</span>
└── <span class="kw">blog-detail.scss</span></code></pre></div>
<p>修改<code>app.ts</code>添加Route:</p>
<pre><code>const ROUTES = [
  {path: &#39;/app/blog/:id&#39;, component: BlogDetailPage}
];

@App({
  template: &#39;&lt;ion-nav [root]=&quot;rootPage&quot;&gt;&lt;/ion-nav&gt;&#39;,
  config: {} 
})
@RouteConfig(ROUTES)
export class MyApp {
  rootPage:any = TabsPage;

  constructor(platform:Platform) {
    this.rootPage = TabsPage;
    this.initializeApp(platform)
  }


  private initializeApp(platform:Platform) {
    platform.ready().then(() =&gt; {
      StatusBar.styleDefault();
    });
  }
}</code></pre>
<p>添加服务</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
  <span class="at">getBlogpostDetail</span>(id) <span class="op">{</span>
    <span class="kw">var</span> url <span class="op">=</span> <span class="st">&#39;http://localhost:8000/api/blogpost/&#39;</span> <span class="op">+</span> id <span class="op">+</span> <span class="st">&#39;?format=json&#39;</span><span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="va">http</span>.<span class="at">get</span>(url).<span class="at">map</span>(res <span class="op">=&gt;</span> res)<span class="op">;</span>
  <span class="op">}</span></code></pre></div>
<p>添加Controller</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span>Page<span class="op">,</span> NavController<span class="op">,</span> NavParams<span class="op">}</span> <span class="im">from</span> <span class="st">&#39;ionic-angular&#39;</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span>BlogpostServices<span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../../services/BlogpostServices&quot;</span><span class="op">;</span>

@<span class="at">Page</span>(<span class="op">{</span>
  <span class="dt">templateUrl</span><span class="op">:</span> <span class="st">&#39;build/pages/blog-detail/blog-detail.html&#39;</span><span class="op">,</span>
  <span class="dt">providers</span><span class="op">:</span> [BlogpostServices]
<span class="op">}</span>)
<span class="im">export</span> <span class="kw">class</span> BlogDetailPage <span class="op">{</span>
  <span class="kw">private</span> navParams<span class="op">;</span>
  <span class="kw">private</span> blogServices<span class="op">;</span>
  <span class="kw">private</span> blogpost<span class="op">;</span>

  <span class="at">constructor</span>(<span class="kw">public</span> <span class="dt">nav</span><span class="op">:</span>NavController<span class="op">,</span> <span class="dt">navParams</span><span class="op">:</span>NavParams<span class="op">,</span> <span class="dt">blogServices</span><span class="op">:</span>BlogpostServices) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">nav</span> <span class="op">=</span> nav<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">navParams</span> <span class="op">=</span> navParams<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">blogServices</span> <span class="op">=</span> blogServices<span class="op">;</span>

    <span class="kw">this</span>.<span class="at">initService</span>()<span class="op">;</span>
  <span class="op">}</span>

  <span class="kw">private</span> <span class="at">initService</span>() <span class="op">{</span>
    <span class="kw">let</span> id <span class="op">=</span> <span class="kw">this</span>.<span class="va">navParams</span>.<span class="at">get</span>(<span class="st">&#39;id&#39;</span>)<span class="op">;</span>
    <span class="kw">this</span>.<span class="va">blogServices</span>.<span class="at">getBlogpostDetail</span>(id).<span class="at">subscribe</span>(
      data <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">blogpost</span> <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">data</span>.<span class="at">_body</span>)<span class="op">;</span>
        <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">blogpost</span>)<span class="op">;</span>
      <span class="op">},</span>
      err <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Error: &#39;</span> <span class="op">+</span> <span class="va">JSON</span>.<span class="at">stringify</span>(err))<span class="op">,</span>
      () <span class="op">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Get Blogpost&#39;</span>)
    )<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h2 id="profile">Profile</h2>
<h3 id="json-web-tokens">Json Web Tokens</h3>
<pre><code>pip install djangorestframework-jwt</code></pre>
<pre><code>urlpatterns = patterns(
    &#39;&#39;,
    # ...

    url(r&#39;^api-token-auth/&#39;, &#39;rest_framework_jwt.views.obtain_jwt_token&#39;),
)</code></pre>
<pre><code>constructor(http: Http, nav:NavController) {
  this.nav = nav;
  this.http = http;
  this.local.get(&#39;id_token&#39;).then(
    (data) =&gt; {
      this.user = this.jwtHelper.decodeToken(data).username;
    }
  );
}

login(credentials) {
  this.contentHeader = new Headers({&quot;Content-Type&quot;: &quot;application/json&quot;});
  this.http.post(this.LOGIN_URL, JSON.stringify(credentials), {headers: this.contentHeader})
    .map(res =&gt; res.json())
    .subscribe(
      data =&gt; this.authSuccess(data.token),
      err =&gt; console.log(err)
    );
}

authSuccess(token) {
  this.local.set(&#39;id_token&#39;, token);
  this.user = this.jwtHelper.decodeToken(token).username;
}</code></pre>
<pre><code>logout() {
  this.local.remove(&#39;id_token&#39;);
  this.user = null;
}</code></pre>
<p>Install Angular JWT</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">npm</span> install angular2-jwt</code></pre></div>
<h3 id="profile-1">Profile</h3>
<pre><code>def list(self, request):
    search_param = self.request.query_params.get(&#39;username&#39;, None)
    if search_param is not None:
        queryset = User.objects.filter(username__contains=search_param)

    serializer = UserSerializer(queryset, many=True)
    return Response(serializer.data)</code></pre>
<h2 id="创建博客">创建博客</h2>
<p>权限管理</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">SAFE_METHODS <span class="op">=</span> [<span class="st">&#39;GET&#39;</span>, <span class="st">&#39;HEAD&#39;</span>, <span class="st">&#39;OPTIONS&#39;</span>]

<span class="kw">class</span> IsAuthenticatedOrReadOnly(BasePermission):
    <span class="co">&quot;&quot;&quot;</span>
<span class="co">    The request is authenticated as a user, or is a read-only request.</span>
<span class="co">    &quot;&quot;&quot;</span>

    <span class="kw">def</span> has_permission(<span class="va">self</span>, request, view):
        <span class="cf">if</span> (request.method <span class="op">in</span> SAFE_METHODS <span class="op">or</span>
            request.user <span class="op">and</span>
            request.user.is_authenticated()):
            <span class="cf">return</span> <span class="va">True</span>
        <span class="cf">return</span> <span class="va">False</span>
<span class="kw">class</span> BlogpsotSerializer(serializers.HyperlinkedModelSerializer):
    <span class="kw">class</span> Meta:
        model <span class="op">=</span> Blogpost
        fields <span class="op">=</span> (<span class="st">&#39;title&#39;</span>, <span class="st">&#39;author&#39;</span>, <span class="st">&#39;body&#39;</span>, <span class="st">&#39;slug&#39;</span>, <span class="st">&#39;id&#39;</span>)


<span class="co"># ViewSets define the view behavior.</span>
<span class="kw">class</span> BlogpostSet(viewsets.ModelViewSet):
    permission_classes <span class="op">=</span> (permissions.IsAuthenticatedOrReadOnly,)
    queryset <span class="op">=</span> Blogpost.objects.<span class="bu">all</span>()
    serializer_class <span class="op">=</span> BlogpsotSerializer</code></pre></div>
<h2 id="todo">TODO</h2>
<h1 id="前端重构">前端重构</h1>
<h2 id="mvvm">MVVM</h2>
<h2 id="ux">UX</h2>
<h1 id="部署">部署</h1>
<h2 id="配置管理">配置管理</h2>
<p>local_settings.py</p>
<h2 id="fabric">Fabric</h2>
<ul>
<li>NGINX - public facing web server</li>
<li>gunicorn - internal HTTP application server</li>
<li>PostgreSQL - database server</li>
<li>memcached - in-memory caching server</li>
<li>supervisord - process control and monitor</li>
<li>virtualenv - isolated Python environments for each project</li>
<li>git or mercurial - version control systems (optional)</li>
</ul>
</body>
</html>
